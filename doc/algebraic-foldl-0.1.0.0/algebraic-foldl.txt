-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/algebraic-foldl#readme</a>
@package algebraic-foldl
@version 0.1.0.0


-- | This module provides utilities for working with <a>Fold</a> and
--   <a>FoldM</a>
module Control.Foldl.Utils

-- | Extract the monadic result from a <a>FoldM</a>
extractM :: Monad m => FoldM m a b -> m b

-- | Produce a <a>FoldM</a> that ignores all input and returns the given
--   monadic value.
pureM :: Monad m => m b -> FoldM m a b

-- | Convert a <a>Fold</a> to a function
toFunction :: Fold a b -> a -> b

-- | Convert a <a>FoldM</a> to a function
toFunctionM :: Monad m => FoldM m a b -> a -> m b

-- | Perform a single step of a <a>Fold</a>
stepFold :: a -> Fold a b -> Fold a b

-- | <a>stepFold</a>, generalized to <a>FoldM</a>
stepFoldM :: Monad m => a -> FoldM m a b -> FoldM m a b

-- | Expose the monadic context of the current state of a <a>FoldM</a>. Can
--   be used, for example, to catch errors before continuing a fold.
unwrapFoldM :: Applicative m => FoldM m a b -> m (FoldM m a b)

-- | Join a monadic result into the monadic context of the <a>FoldM</a>
innerJoinFoldM :: Monad m => FoldM m a (m b) -> FoldM m a b

-- | Generalize a <a>Fold</a> returning <a>Maybe</a> to <a>MaybeT</a>.
--   
--   For example:
--   
--   <pre>
--   λ&gt; F.foldM (generalizeMaybe F.head) [1..10] :: MaybeT Identity Int
--   MaybeT (Identity (Just 1))
--   </pre>
generalizeMaybe :: Monad m => Fold a (Maybe b) -> FoldM (MaybeT m) a b

-- | Count the number of elements that match a predicate
--   
--   Should be equivalent to: length . prefilter p
count :: Enum i => (a -> Bool) -> Fold a i

-- | <a>count</a> using a monadic predicate
countM :: (Enum i, Monad m) => (a -> m Bool) -> FoldM m a i
instance GHC.Base.Monad m => Data.Functor.Extend.Extend (Control.Foldl.FoldM m a)


-- | This module provides a version of <a>Fold</a> that only accepts
--   non-empty inputs
module Control.Foldl.NonEmpty

-- | <a>Fold</a> with a guaranteed non-empty input
newtype Fold1 a b
Fold1 :: ReaderT a (Fold a) b -> Fold1 a b
[runFold1] :: Fold1 a b -> ReaderT a (Fold a) b

-- | Apply a <a>Fold1</a> to a possibly empty <a>Foldable</a>
fold1 :: Foldable t => Fold1 a b -> t a -> Maybe b

-- | <a>fold1</a> with provided initial input
fold1With :: Foldable t => Fold1 a b -> a -> t a -> b

-- | Apply a <a>Fold1</a> to a <a>NonEmpty</a>
fold1NonEmpty :: Fold1 a b -> NonEmpty a -> b

-- | Convert a <a>Fold1</a> to a <a>Fold</a> by returning <a>Nothing</a>
--   when there's no input
fromFold1 :: Fold1 a b -> Fold a (Maybe b)

-- | <a>fromFold1</a> with provided initial input
fromFold1With :: Fold1 a b -> a -> Fold a b

-- | Convert a <a>Fold</a> to a <a>Fold1</a> by passing the
--   <a>ReaderT</a>-provided argument to <a>stepFold</a> and using it to
--   update the <a>Fold</a>
toFold1 :: Fold a b -> Fold1 a b

-- | The first element of a non-empty collection
head1 :: Fold1 a a

-- | The last element of a non-empty collection
last1 :: Fold1 a a
instance GHC.Base.Applicative (Control.Foldl.NonEmpty.Fold1 a)
instance GHC.Base.Functor (Control.Foldl.NonEmpty.Fold1 a)
instance Data.Profunctor.Unsafe.Profunctor Control.Foldl.NonEmpty.Fold1


-- | This module provides a <tt>FoldE1</tt> that returns a non-empty stream
--   of outputs
module Control.Foldls.End.NonEmpty

-- | Add newtype declaration, instances, etc.
todo :: ()


-- | This module provides a <tt>FoldsM</tt> that can return early
module Control.Foldls.Monadic.End

-- | Add newtype declaration, instances, etc.
todo :: ()


-- | This module defines a pseudo <a>Monad</a>/<a>Comonad</a> transformer
--   <a>ConstT</a> that ignores the provided <tt>* -&gt; *</tt> type.
module Control.Monad.Trans.Const

-- | Ignores the first argument. <a>ConstT</a> is neither a <a>Monad</a>
--   transformer nor a <a>Comonad</a> transformer.
newtype ConstT (m :: * -> *) a
ConstT :: a -> ConstT a
[runConstT] :: ConstT a -> a

-- | <a>ConstT</a> implemented in terms of <a>coerce</a>
constT :: a -> ConstT m a

-- | <a>runConstT</a> implemented in terms of <a>coerce</a>
unConstT :: ConstT m a -> a
instance GHC.Generics.Generic1 (Control.Monad.Trans.Const.ConstT m)
instance GHC.Generics.Generic (Control.Monad.Trans.Const.ConstT m a)
instance Data.Traversable.Traversable (Control.Monad.Trans.Const.ConstT m)
instance Data.Foldable.Foldable (Control.Monad.Trans.Const.ConstT m)
instance GHC.Base.Functor (Control.Monad.Trans.Const.ConstT m)
instance Data.Functor.Classes.Eq1 (Control.Monad.Trans.Const.ConstT m)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Monad.Trans.Const.ConstT m a)
instance Data.Functor.Classes.Ord1 (Control.Monad.Trans.Const.ConstT m)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Monad.Trans.Const.ConstT m a)
instance Data.Functor.Classes.Show1 (Control.Monad.Trans.Const.ConstT m)
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Trans.Const.ConstT m a)
instance Data.Functor.Classes.Read1 (Control.Monad.Trans.Const.ConstT m)
instance GHC.Read.Read a => GHC.Read.Read (Control.Monad.Trans.Const.ConstT m a)
instance Control.Comonad.Comonad (Control.Monad.Trans.Const.ConstT m)
instance Control.Comonad.ComonadApply (Control.Monad.Trans.Const.ConstT m)
instance Control.Comonad.Hoist.Class.ComonadHoist Control.Monad.Trans.Const.ConstT
instance GHC.Base.Applicative (Control.Monad.Trans.Const.ConstT m)
instance GHC.Base.Monad (Control.Monad.Trans.Const.ConstT m)
instance Control.Monad.Fix.MonadFix (Control.Monad.Trans.Const.ConstT m)


-- | This module defines <a>Distributive</a> for a fixed <a>Monad</a>
--   instead of an arbitrary <a>Functor</a>.
module Data.Distributive.Monadic

-- | This is the categorical dual of <a>Traversable</a>, for a <a>Monad</a>
--   fixed by our choice of <tt>f</tt>.
--   
--   If you define one of <a>distributem</a>, <a>collectm</a> you may
--   define the other using <a>collectmByDistributem</a>,
--   <a>distributemByCollectm</a>, respectively.
--   
--   All <a>MonadTrans</a>formers that result in a <a>Monad</a> are
--   instances of <a>DistributiveM</a>, see <a>collectmTrans</a>.
class Monad m => DistributiveM m f | f -> m

-- | The dual of <a>sequence</a>, for a fixed <a>Monad</a>
--   
--   <pre>
--   <a>distributem</a> = <a>collectm</a> <a>id</a>
--   </pre>
distributem :: DistributiveM m f => m (f a) -> f (m a)

-- | The dual of <a>sequence</a>, for a fixed <a>Monad</a>
--   
--   <pre>
--   <a>distributem</a> = <a>collectm</a> <a>id</a>
--   </pre>
distributem :: (DistributiveM m f, Generic1 f, GDistributiveM m (Rep1 f)) => m (f a) -> f (m a)

-- | Map then <a>distributem</a>:
--   
--   <pre>
--   <a>collectm</a> f = <a>distributem</a> . <a>fmap</a> f
--   </pre>
collectm :: DistributiveM m f => (a -> f b) -> m a -> f (m b)

-- | Map then <a>distributem</a>:
--   
--   <pre>
--   <a>collectm</a> f = <a>distributem</a> . <a>fmap</a> f
--   </pre>
collectm :: (DistributiveM m f, Generic1 f, GDistributiveM m (Rep1 f)) => (a -> f b) -> m a -> f (m b)

-- | <a>distributem</a> in terms of <a>collectm</a>
distributemByCollectm :: DistributiveM m f => m (f a) -> f (m a)

-- | <a>collectm</a> in terms of <a>distributem</a>
collectmByDistributem :: DistributiveM m f => (a -> f b) -> m a -> f (m b)

-- | Implement <tt>wrap</tt> using <a>distributem</a> and
--   <a>innerJoinFoldM</a>
wrapFoldM :: Monad m => m (FoldM m a b) -> FoldM m a b

-- | Ignores the first argument. <a>ConstT</a> is neither a <a>Monad</a>
--   transformer nor a <a>Comonad</a> transformer.
newtype ConstT (m :: * -> *) a
ConstT :: a -> ConstT a
[runConstT] :: ConstT a -> a

-- | <a>distributem</a> for any <a>MonadTrans</a> that's a <a>Monad</a>
--   when its base functor is.
distributemTrans :: (Monad m, MonadTrans t, Monad (t m)) => m (t m a) -> t m (m a)

-- | <a>collectm</a> for any <a>MonadTrans</a> that's a <a>Monad</a> when
--   its base functor is.
--   
--   We <a>lift</a> the <tt>m</tt> then <tt>(<a>&gt;&gt;=</a>)</tt> the
--   function to the result. Finally, we <a>return</a> inside of the
--   transformer.
collectmTrans :: (Monad m, MonadTrans t, Monad (t m)) => (a -> t m b) -> m a -> t m (m b)

-- | A default implementation of <a>distributem</a> for <a>Generic1</a>
--   types
gdistributem :: (GDistributiveM m (Rep1 f), Generic1 f) => m (f a) -> f (m a)

-- | A default implementation of <a>collectm</a> for <a>Generic1</a> types
gcollectm :: (GDistributiveM m (Rep1 f), Generic1 f) => (a -> f b) -> m a -> f (m b)

-- | The typeclass implementing <a>gdistributem</a> (as
--   <a>gdistributem'</a>) for <a>Generic1</a> types
class Monad m => GDistributiveM (m :: * -> *) (f :: * -> *) | f -> m
gdistributem' :: GDistributiveM m f => m (f a) -> f (m a)
gcollectm' :: GDistributiveM m f => (a -> f b) -> m a -> f (m b)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Foldl.FoldM m a)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Const.ConstT m)
instance (Data.Distributive.Monadic.DistributiveM m f, Data.Distributive.Monadic.DistributiveM m g) => Data.Distributive.Monadic.DistributiveM m (f GHC.Generics.:*: g)
instance (Data.Distributive.Monadic.DistributiveM m f, Data.Distributive.Monadic.DistributiveM m g, GHC.Base.Functor f) => Data.Distributive.Monadic.DistributiveM m (f GHC.Generics.:.: g)
instance (Data.Distributive.Monadic.DistributiveM m f, Data.Distributive.Monadic.DistributiveM m g, GHC.Base.Functor f) => Data.Distributive.Monadic.DistributiveM m (Data.Functor.Compose.Compose f g)
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity GHC.Generics.Par1
instance Data.Distributive.Monadic.DistributiveM m f => Data.Distributive.Monadic.DistributiveM m (GHC.Generics.M1 i c f)
instance Data.Distributive.Monadic.DistributiveM m f => Data.Distributive.Monadic.DistributiveM m (GHC.Generics.Rec1 f)
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity GHC.Generics.U1
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Functor.Identity.Identity
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Complex.Complex
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Semigroup.Internal.Dual
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Semigroup.Internal.Sum
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Semigroup.Internal.Product
instance Data.Distributive.Monadic.DistributiveM Data.Functor.Identity.Identity Data.Proxy.Proxy
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Accum.AccumT w m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Cont.ContT r m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Comonad.Comonad m, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Trans.Env.EnvT e m)
instance (Control.Comonad.Comonad m, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Trans.Store.StoreT s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Trans.Traced.TracedT w m)
instance (Control.Comonad.Comonad m, GHC.Base.Monad m) => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Cofree.Cofree m)
instance (Data.Distributive.Monadic.DistributiveM m f, GHC.Base.Functor f) => Data.Distributive.Monadic.DistributiveM m (Data.Distributive.Monadic.WrappedCofreeF m f)
instance (Data.Distributive.Monadic.DistributiveM m f, GHC.Base.Functor f) => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Trans.Cofree.CofreeT m f)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Comonad.Trans.Coiter.CoiterT m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Free.Free m)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Free.Church.F m)
instance (GHC.Base.Monad m, GHC.Base.Monad n) => Data.Distributive.Monadic.DistributiveM m (Data.Distributive.Monadic.WrappedFreeF m n)
instance (Data.Distributive.Monadic.DistributiveM m n, GHC.Base.Monad n) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Free.FreeT m n)
instance (Data.Distributive.Monadic.DistributiveM m n, GHC.Base.Monad n) => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Free.Church.FT m n)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM m (Control.Monad.Trans.Iter.IterT m)
instance Data.Distributive.Monadic.DistributiveM m f => Data.Distributive.Monadic.GDistributiveM m (GHC.Generics.Rec1 f)
instance (Data.Distributive.Monadic.DistributiveM m f, Data.Distributive.Monadic.GDistributiveM m g, GHC.Base.Functor f) => Data.Distributive.Monadic.GDistributiveM m (f GHC.Generics.:.: g)
instance Data.Distributive.Monadic.GDistributiveM m f => Data.Distributive.Monadic.GDistributiveM m (GHC.Generics.M1 i c f)
instance Data.Distributive.Monadic.GDistributiveM Data.Functor.Identity.Identity GHC.Generics.U1
instance Data.Distributive.Monadic.GDistributiveM Data.Functor.Identity.Identity GHC.Generics.Par1
instance (Data.Distributive.Monadic.GDistributiveM m f, Data.Distributive.Monadic.GDistributiveM m g) => Data.Distributive.Monadic.GDistributiveM m (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, GHC.Base.Monad m) => GHC.Base.Functor (Data.Distributive.Monadic.WrappedFreeF f m)
instance (GHC.Base.Functor f, GHC.Base.Functor w) => GHC.Base.Functor (Data.Distributive.Monadic.WrappedCofreeF f w)


-- | This module defines a version of <tt>Representable</tt> where the
--   function tabulated/indexed returns a monadic result.
--   
--   In other words, instead of providing an isomorphism with
--   <tt>Reader</tt>, we provide one with <a>ReaderT</a> for a fixed
--   <a>Monad</a>.
module Control.Monad.Rep

-- | A <a>Functor</a> <tt>f</tt> is <a>RepresentableM</a> for a given
--   <a>Monad</a> <tt>m</tt> if <a>tabulateM</a> and <a>indexM</a> witness
--   an isomorphism to <tt><a>ReaderT</a> (<a>RepM</a> f) m</tt>.
--   
--   <pre>
--   <a>tabulateM</a> . <a>indexM</a> == <a>id</a>
--   <a>indexM</a> . <a>tabulateM</a> == <a>id</a>
--   <a>tabulateM</a> . <a>return</a> . <a>return</a> == <a>return</a>
--   </pre>
--   
--   Every <a>RepresentableM</a> <a>Functor</a> whose base <a>Monad</a> is
--   a right adjoint is also a right adjoint.
--   
--   Inuitively, a <a>RepresentableM</a> <a>Functor</a> is a
--   <tt>Representable</tt> <a>Functor</a> on the Kleisli category of the
--   base <a>Monad</a>.
--   
--   I'd expect some superclass requirement, but it ends up looking like
--   just <tt><a>Applicative</a> f</tt>:
--   
--   <pre>
--   class <a>Applicative</a> f =&gt; DistributiveA f where
--     distributeM :: <a>Traversable</a> t =&gt; t (f a) -&gt; f (t a)
--   
--   instance <a>Applicative</a> m =&gt; DistributiveM (<a>ReaderT</a> a m) where
--     distributeM = <a>ReaderT</a> . <a>fmap</a> <a>sequenceA</a> . <a>distribute</a> . <a>fmap</a> <a>runReaderT</a>
--   </pre>
class DistributiveM m f => RepresentableM m f | f -> m where {
    type family RepM f :: *;
    type RepM f = GRepM f;
}

-- | <pre>
--   <a>fmap</a> (<a>fmap</a> f) . <a>tabulateM</a> == <a>tabulateM</a> . <a>fmap</a> f
--   </pre>
--   
--   If no definition is provided, this will default to <a>gtabulateM</a>.
tabulateM :: RepresentableM m f => (RepM f -> m a) -> f a

-- | <pre>
--   <a>fmap</a> (<a>fmap</a> f) . <a>tabulateM</a> == <a>tabulateM</a> . <a>fmap</a> f
--   </pre>
--   
--   If no definition is provided, this will default to <a>gtabulateM</a>.
tabulateM :: (RepresentableM m f, Generic1 f, GRepM f ~ RepM f, GTabulateM m (Rep1 f)) => (RepM f -> m a) -> f a

-- | If no definition is provided, this will default to <a>gindexM</a>.
indexM :: RepresentableM m f => f a -> (RepM f -> m a)

-- | If no definition is provided, this will default to <a>gindexM</a>.
indexM :: (RepresentableM m f, Generic1 f, GRepM f ~ RepM f, GIndexM m (Rep1 f)) => f a -> (RepM f -> m a)

-- | <a>fmap</a> inside the <a>Monad</a>ic result of a
--   <a>RepresentableM</a>
fmapRepM :: RepresentableM m f => (a -> b) -> f a -> f b

-- | <a>collect</a> after <a>indexM</a>ing
distributeRepM :: (RepresentableM m f, Distributive m, Functor w) => w (f a) -> f (w a)

-- | <a>collect</a> after <a>indexM</a>ing the result of the provided
--   function
collectRepM :: (RepresentableM m f, Distributive m, Functor w) => (a -> f b) -> w a -> f (w b)

-- | <a>distributem</a> for <a>RepresentableM</a>
distributemRepM :: RepresentableM m f => m (f a) -> f (m a)

-- | <a>collect</a> for <a>RepresentableM</a>
collectmRepM :: RepresentableM m f => (a -> f b) -> m a -> f (m b)

-- | Uses the isomorphism
apRepM :: RepresentableM m f => f (a -> b) -> f a -> f b

-- | <a>tabulateM</a> ignoring the index and <a>return</a>ing the value
pureRepM :: RepresentableM m f => a -> f a

-- | Uses the isomorphism
liftRM2 :: RepresentableM m f => (a -> b -> c) -> f a -> f b -> f c

-- | Uses the isomorphism
liftRM3 :: RepresentableM m f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Equivalent to:
--   
--   <pre>
--   \m f -&gt; <a>runReaderT</a> $ <a>toReaderT</a> m <a>&gt;&gt;=</a> <a>toReaderT</a> . f
--   </pre>
bindRepM :: RepresentableM m f => f a -> (a -> f b) -> f b

-- | Equivalent to:
--   
--   <pre>
--   <a>runReaderT</a> . <a>mfix</a> . <a>fmap</a> <a>toReaderT</a>
--   </pre>
mfixRepM :: (RepresentableM m f, MonadFix m) => (a -> f a) -> f a

-- | <a>indexM</a>, <a>mzipWith</a>, then <a>tabulateM</a>
mzipWithRepM :: (RepresentableM m f, MonadZip m) => (a -> b -> c) -> f a -> f b -> f c

-- | <a>indexM</a>, <a>mzip</a>, then <a>tabulateM</a>
mzipRepM :: (RepresentableM m f, MonadZip m) => f a -> f b -> f (a, b)

-- | <tt><a>RepresentableM</a> m f</tt> is isomorphic to <tt><a>ReaderT</a>
--   (<a>RepM</a> f) m a</tt>:
--   
--   <pre>
--   <a>fromReaderT</a> . <a>toReaderT</a> == <a>id</a>
--   <a>toReaderT</a> . <a>fromReaderT</a> == <a>id</a>
--   </pre>
fromReaderT :: RepresentableM m f => ReaderT (RepM f) m a -> f a

-- | The other half of the isomorphism, see: <a>fromReaderT</a>
toReaderT :: RepresentableM m f => f a -> ReaderT (RepM f) m a

-- | Fetch the value of the environment.
--   
--   (<tt>ask</tt> specialized to <a>RepresentableM</a>)
askRepM :: RepresentableM m f => f (RepM f)

-- | Retrieve a function of the current environment.
--   
--   (<tt>asks</tt> specialized to <a>RepresentableM</a>)
asksRepM :: RepresentableM m f => (RepM f -> a) -> f a

-- | Transform the computation inside a <a>RepresentableM</a>.
--   
--   (<tt>mapReaderT</tt> specialized to <a>RepresentableM</a>)
mapRepM :: RepresentableM m f => (m a -> m b) -> f a -> f b

-- | Execute a computation in a modified environment.
--   
--   (<tt>withReaderT</tt> specialized to <a>RepresentableM</a>)
withRepM :: RepresentableM m f => (RepM f -> RepM f) -> f a -> f a

-- | Execute a computation in a modified environment.
--   
--   (<tt>local</tt> specialized to <a>RepresentableM</a>)
localRepM :: RepresentableM m f => (RepM f -> RepM f) -> f a -> f a

-- | <pre>
--   <a>duplicateRepMBy</a> (<a>&lt;&gt;</a>)
--   </pre>
duplicatedRepM :: (RepresentableM m f, Semigroup (RepM f)) => f a -> f (f a)

-- | <pre>
--   <a>extendRepMBy</a> (<a>&lt;&gt;</a>)
--   </pre>
extendedRepM :: (RepresentableM m f, Semigroup (RepM f)) => (f a -> b) -> f a -> f b

-- | <pre>
--   <a>duplicateRepMBy</a> <a>mappend</a>
--   </pre>
duplicateRepM :: (RepresentableM m f, Monoid (RepM f)) => f a -> f (f a)

-- | <pre>
--   <a>extendRepMBy</a> <a>mappend</a>
--   </pre>
extendRepM :: (RepresentableM m f, Monoid (RepM f)) => (f a -> b) -> f a -> f b

-- | <pre>
--   <a>extractRepMBy</a> <a>mempty</a>
--   </pre>
extractRepM :: (RepresentableM m f, Monoid (RepM f), Comonad m) => f a -> a

-- | <a>indexM</a> then <a>tabulateM</a> twice and use the provided
--   operation to combine the keys
duplicateRepMBy :: RepresentableM m f => (RepM f -> RepM f -> RepM f) -> f a -> f (f a)

-- | <a>indexM</a> then <a>tabulateM</a> twice and use the provided
--   operation to combine the keys
extendRepMBy :: RepresentableM m f => (RepM f -> RepM f -> RepM f) -> (f a -> b) -> f a -> f b

-- | Since we need to return a raw value, <tt>m</tt> must be a
--   <a>Comonad</a>
extractRepMBy :: (RepresentableM m f, Comonad m) => RepM f -> f a -> a

-- | <a>tabulateM</a> to expose the <a>RepM</a> and then <a>fmap</a>
imapRepM :: RepresentableM m f => (RepM f -> a -> b) -> f a -> f b

-- | <a>tabulateM</a> to expose the <a>RepM</a> and then (<a>&gt;&gt;=</a>)
imapMRepM :: RepresentableM m f => (RepM f -> a -> m b) -> f a -> f b

-- | Indexed <a>foldMap</a>
ifoldMapRepM :: forall m f a b. (RepresentableM m f, Foldable f, Monoid b) => (RepM f -> a -> b) -> f a -> b

-- | Indexed <a>traverse</a>
itraverseRepM :: (RepresentableM m f, Traversable f, Applicative g) => (RepM f -> a -> g b) -> f a -> g (f b)

-- | Wrap the base <a>Monad</a> of a <a>RepresentableM</a>
wrapRepM :: RepresentableM m f => m (f a) -> f a

-- | Lift the base <a>Monad</a> of a <a>RepresentableM</a>
liftRepM :: RepresentableM m f => m a -> f a

-- | Lift a <tt>callCC</tt> operation to the base <a>Monad</a>.
liftCallCC :: RepresentableM m f => (((a -> m b) -> m a) -> m a) -> ((a -> f b) -> f a) -> f a

-- | Lift a <tt>catchError</tt> operation to the base monad.
liftCatch :: RepresentableM m f => (m a -> (RepM f -> m a) -> m a) -> f a -> (RepM f -> f a) -> f a

-- | A default implementation of <a>tabulateM</a> in terms of <a>GRepM</a>.
gtabulateM :: (Generic1 f, GRepM f ~ RepM f, GTabulateM m (Rep1 f)) => (RepM f -> m a) -> f a

-- | A default implementation of <a>indexM</a> in terms of <a>GRepM</a>.
gindexM :: (Generic1 f, GRepM f ~ RepM f, GIndexM m (Rep1 f)) => f a -> (RepM f -> m a)

-- | A convenient composition of <a>GRepM'</a> and <a>Rep1</a>
type GRepM f = GRepM' (Rep1 f)

-- | Generic <a>RepM</a>, with a customer <a>TypeError</a> for unsupported
--   types.

-- | The typeclass implementing <a>gtabulateM</a> (as <a>gtabulateM'</a>)
--   for <a>Generic</a> types
class Monad m => GTabulateM (m :: * -> *) (f :: * -> *) | f -> m
gtabulateM' :: GTabulateM m f => (GRepM' f -> m a) -> f a

-- | The typeclass implementing <a>gindexM</a> (as <a>gindexM'</a>) for
--   <a>Generic</a> types
class Monad m => GIndexM (m :: * -> *) (f :: * -> *) | f -> m
gindexM' :: GIndexM m f => f a -> (GRepM' f -> m a)

-- | <a>WrappedRepM</a> prevents generic <a>RepresentableM</a> instances
--   for recursive types from sending the typechecker into an infinite
--   loop.
--   
--   See <tt>WrappedRep</tt>.
newtype WrappedRepM f
WrapRepM :: RepM f -> WrappedRepM f
[unwrapRepM] :: WrappedRepM f -> RepM f

-- | <tt>Cofree</tt>, <tt>CofreeT</tt> instances
todo :: ()
instance Data.Bits.Bits (Control.Monad.Rep.RepM f) => Data.Bits.Bits (Control.Monad.Rep.WrappedRepM f)
instance GHC.Enum.Bounded (Control.Monad.Rep.RepM f) => GHC.Enum.Bounded (Control.Monad.Rep.WrappedRepM f)
instance (Data.Data.Data (Control.Monad.Rep.RepM f), Data.Typeable.Internal.Typeable f) => Data.Data.Data (Control.Monad.Rep.WrappedRepM f)
instance GHC.Enum.Enum (Control.Monad.Rep.RepM f) => GHC.Enum.Enum (Control.Monad.Rep.WrappedRepM f)
instance GHC.Classes.Eq (Control.Monad.Rep.RepM f) => GHC.Classes.Eq (Control.Monad.Rep.WrappedRepM f)
instance Data.Bits.FiniteBits (Control.Monad.Rep.RepM f) => Data.Bits.FiniteBits (Control.Monad.Rep.WrappedRepM f)
instance GHC.Float.Floating (Control.Monad.Rep.RepM f) => GHC.Float.Floating (Control.Monad.Rep.WrappedRepM f)
instance GHC.Real.Fractional (Control.Monad.Rep.RepM f) => GHC.Real.Fractional (Control.Monad.Rep.WrappedRepM f)
instance GHC.Generics.Generic (Control.Monad.Rep.RepM f) => GHC.Generics.Generic (Control.Monad.Rep.WrappedRepM f)
instance GHC.Arr.Ix (Control.Monad.Rep.RepM f) => GHC.Arr.Ix (Control.Monad.Rep.WrappedRepM f)
instance GHC.Base.Monoid (Control.Monad.Rep.RepM f) => GHC.Base.Monoid (Control.Monad.Rep.WrappedRepM f)
instance GHC.Num.Num (Control.Monad.Rep.RepM f) => GHC.Num.Num (Control.Monad.Rep.WrappedRepM f)
instance GHC.Classes.Ord (Control.Monad.Rep.RepM f) => GHC.Classes.Ord (Control.Monad.Rep.WrappedRepM f)
instance Text.Printf.PrintfArg (Control.Monad.Rep.RepM f) => Text.Printf.PrintfArg (Control.Monad.Rep.WrappedRepM f)
instance GHC.Read.Read (Control.Monad.Rep.RepM f) => GHC.Read.Read (Control.Monad.Rep.WrappedRepM f)
instance GHC.Real.Real (Control.Monad.Rep.RepM f) => GHC.Real.Real (Control.Monad.Rep.WrappedRepM f)
instance GHC.Float.RealFloat (Control.Monad.Rep.RepM f) => GHC.Float.RealFloat (Control.Monad.Rep.WrappedRepM f)
instance GHC.Real.RealFrac (Control.Monad.Rep.RepM f) => GHC.Real.RealFrac (Control.Monad.Rep.WrappedRepM f)
instance GHC.Base.Semigroup (Control.Monad.Rep.RepM f) => GHC.Base.Semigroup (Control.Monad.Rep.WrappedRepM f)
instance GHC.Show.Show (Control.Monad.Rep.RepM f) => GHC.Show.Show (Control.Monad.Rep.WrappedRepM f)
instance Foreign.Storable.Storable (Control.Monad.Rep.RepM f) => Foreign.Storable.Storable (Control.Monad.Rep.WrappedRepM f)
instance (Control.Monad.Rep.RepresentableM m f, Control.Monad.Rep.RepresentableM m g) => Control.Monad.Rep.RepresentableM m (f GHC.Generics.:*: g)
instance (Control.Monad.Rep.RepresentableM m f, Control.Monad.Rep.RepresentableM m g, GHC.Base.Monad (f GHC.Generics.:.: g), GHC.Base.Functor f) => Control.Monad.Rep.RepresentableM m (f GHC.Generics.:.: g)
instance (Control.Monad.Rep.RepresentableM m f, Control.Monad.Rep.RepresentableM m g, GHC.Base.Monad (Data.Functor.Compose.Compose f g), GHC.Base.Functor f) => Control.Monad.Rep.RepresentableM m (Data.Functor.Compose.Compose f g)
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity GHC.Generics.Par1
instance Control.Monad.Rep.RepresentableM m f => Control.Monad.Rep.RepresentableM m (GHC.Generics.M1 i c f)
instance Control.Monad.Rep.RepresentableM m f => Control.Monad.Rep.RepresentableM m (GHC.Generics.Rec1 f)
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity GHC.Generics.U1
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Functor.Identity.Identity
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Complex.Complex
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Semigroup.Internal.Dual
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Semigroup.Internal.Sum
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Semigroup.Internal.Product
instance Control.Monad.Rep.RepresentableM Data.Functor.Identity.Identity Data.Proxy.Proxy
instance GHC.Base.Monad m => Control.Monad.Rep.RepresentableM m (Control.Monad.Trans.Reader.ReaderT a m)
instance (Control.Monad.Rep.GTabulateM m f, Control.Monad.Rep.GTabulateM m g) => Control.Monad.Rep.GTabulateM m (f GHC.Generics.:*: g)
instance Control.Monad.Rep.GTabulateM Data.Functor.Identity.Identity GHC.Generics.Par1
instance Control.Monad.Rep.GTabulateM m f => Control.Monad.Rep.GTabulateM m (GHC.Generics.M1 i c f)
instance (Control.Monad.Rep.RepresentableM m f, Control.Monad.Rep.GTabulateM m g) => Control.Monad.Rep.GTabulateM m (f GHC.Generics.:.: g)
instance Control.Monad.Rep.RepresentableM m f => Control.Monad.Rep.GTabulateM m (GHC.Generics.Rec1 f)
instance Control.Monad.Rep.GTabulateM Data.Functor.Identity.Identity GHC.Generics.U1
instance (Control.Monad.Rep.GIndexM m f, Control.Monad.Rep.GIndexM m g) => Control.Monad.Rep.GIndexM m (f GHC.Generics.:*: g)
instance Control.Monad.Rep.GIndexM Data.Functor.Identity.Identity GHC.Generics.Par1
instance Control.Monad.Rep.GIndexM m f => Control.Monad.Rep.GIndexM m (GHC.Generics.M1 i c f)
instance (Control.Monad.Rep.RepresentableM m f, Control.Monad.Rep.GIndexM m g) => Control.Monad.Rep.GIndexM m (f GHC.Generics.:.: g)
instance Control.Monad.Rep.RepresentableM m f => Control.Monad.Rep.GIndexM m (GHC.Generics.Rec1 f)
instance Control.Monad.Rep.GIndexM Data.Functor.Identity.Identity GHC.Generics.U1


-- | This module defines some utilities for <a>Either</a>
module Data.Either.Utils

-- | Unwrap an <a>Either</a> with equal types
joinEither :: Either a a -> a

-- | Combine <a>Left</a>s using the provided function
combineLefts :: (a -> b -> c) -> Either a d -> Either b e -> Either c (Either a d, Either b e)


-- | This module provides a version of <tt>Foldl</tt> in terms of
--   <a>Cofree</a> and <a>ReaderT</a> that's isomorphic to <tt>Foldl</tt>.
module Control.Foldl.Free

-- | By expressing the state of a left fold as a <a>Cofree</a>:
--   
--   <pre>
--   Cofree (current state, new value -&gt; monadic context (new state, new new value -&gt; ..))
--   </pre>
--   
--   we can express arbitrary recursions, one step at a time, and allowing
--   things like:
--   
--   <pre>
--   If even x then replace all further functions with const 0.
--   </pre>
--   
--   This allows us ~(in theory)~ to much more efficiently express
--   combinators such as <tt>foldEThenE</tt>.
--   
--   Note: this type is isomorphic to <a>FoldM</a>.
newtype FreeFoldM m a b
FreeFoldM :: m (Cofree (ReaderT a m) b) -> FreeFoldM m a b
[runFreeFoldM] :: FreeFoldM m a b -> m (Cofree (ReaderT a m) b)

-- | A pure <a>FreeFoldM</a>
type FreeFold = FreeFoldM Identity

-- | Helper to abstract-out wrapping and unwrapping a <a>FreeFoldM</a>
withFreeFoldM :: (m (Cofree (ReaderT a m) b) -> n (Cofree (ReaderT c n) d)) -> FreeFoldM m a b -> FreeFoldM n c d

-- | Helper to abstract-out wrapping and unwrapping a <a>FreeFoldM</a>
withFreeFoldM2 :: (m1 (Cofree (ReaderT a1 m1) b1) -> m2 (Cofree (ReaderT a2 m2) b2) -> m3 (Cofree (ReaderT a3 m3) b3)) -> FreeFoldM m1 a1 b1 -> FreeFoldM m2 a2 b2 -> FreeFoldM m3 a3 b3

-- | Helper to abstract-out wrapping and unwrapping a pair of
--   <a>FreeFoldM</a>'s
asFreeFoldM2 :: (FreeFoldM m1 a1 b1 -> FreeFoldM m2 a2 b2 -> FreeFoldM m3 a3 b3) -> m1 (Cofree (ReaderT a1 m1) b1) -> m2 (Cofree (ReaderT a2 m2) b2) -> m3 (Cofree (ReaderT a3 m3) b3)

-- | Extract the first result from a <a>FreeFoldM</a>
extractFreeFoldM :: Functor m => FreeFoldM m a b -> m b

-- | Expose a layer of a <a>FreeFold</a>
unwrapFreeFold :: FreeFold a b -> Reader a (FreeFold a b)

-- | Expose a layer of a <a>FreeFoldM</a>
unwrapFreeFoldM :: Monad m => FreeFoldM m a b -> ReaderT a m (FreeFoldM m a b)

-- | Wrap a <a>Monad</a>ic layer around a <a>FreeFoldM</a>
wrapFreeFoldM :: Monad m => m (FreeFoldM m a b) -> FreeFoldM m a b

-- | Construct a <a>Fold</a> from a <a>FreeFold</a>.
--   
--   (This is the the inverse of <a>toFreeFold</a>.)
freeFold :: FreeFold a b -> Fold a b

-- | Construct a <a>FoldM</a> from a <a>FreeFoldM</a>.
--   
--   (This is the the inverse of <a>toFreeFoldM</a>.)
freeFoldM :: Monad m => FreeFoldM m a b -> FoldM m a b

-- | Convert a <a>Fold</a> to a <a>FreeFold</a>.
--   
--   (This is the inverse of <a>freeFold</a>.)
toFreeFold :: Fold a b -> FreeFold a b

-- | Convert a <a>FoldM</a> to a <a>FreeFoldM</a>.
--   
--   (This is the inverse of <a>freeFoldM</a>.)
toFreeFoldM :: Monad m => FoldM m a b -> FreeFoldM m a b

-- | Perform a single step of a <a>FreeFold</a>
stepFreeFold :: a -> FreeFold a b -> FreeFold a b

-- | Perform a single step of a <a>FreeFoldM</a>
stepFreeFoldM :: Monad m => a -> FreeFoldM m a b -> FreeFoldM m a b

-- | Skip the first step of a <a>FreeFold</a>
skipFreeFold :: FreeFold a b -> FreeFold a b

-- | Skip the first step of a <a>FreeFoldM</a>
skipFreeFoldM :: Monad m => FreeFoldM m a b -> FreeFoldM m a b

-- | Fold with the first until <a>Left</a>, then use its result to
--   construct the second fold and continue.
foldFreeThenFree :: FreeFoldM (Either b) a b -> (b -> FreeFoldM (Either c) a c) -> FreeFoldM (Either c) a c

-- | Fold with the first, extracting each result to provide to the
--   <a>Cofree</a>, until <a>Left</a>, then use its result to construct the
--   second <a>Cofree</a> <a>ReaderT</a> and continue.
foldCofreeThenCofree :: Cofree (ReaderT a (Either b)) b -> (b -> Either c (Cofree (ReaderT a (Either c)) c)) -> Either c (Cofree (ReaderT a (Either c)) c)

-- | <a>foldFreeThenFree</a> generalized to <a>ExceptT</a>
foldFreeThenFreeM :: Monad m => FreeFoldM (ExceptT b m) a b -> (b -> FreeFoldM (ExceptT c m) a c) -> FreeFoldM (ExceptT c m) a c

-- | <a>foldCofreeThenCofree</a> generalized to <a>ExceptT</a>
foldCofreeThenCofreeM :: Monad m => Cofree (ReaderT a (ExceptT b m)) b -> (b -> ExceptT c m (Cofree (ReaderT a (ExceptT c m)) c)) -> ExceptT c m (Cofree (ReaderT a (ExceptT c m)) c)

-- | Given cases for one or <tt>(previous, current)</tt> elements and a
--   fold over the results, produce a combined <a>FreeFoldM</a>.
foldFree2 :: (a -> b) -> (a -> a -> b) -> FreeFoldM (Either c) b c -> FreeFoldM (Either c) a c

-- | Given cases for one or <tt>(previous, current)</tt> elements and a
--   fold over the results, produce a combined fold.
foldCofree2 :: (a -> b) -> (a -> a -> b) -> Cofree (ReaderT b (Either c)) c -> Cofree (ReaderT a (Either c)) c

-- | Resolve paired to unpaired inputs by prepending a <a>ReaderT</a>
unpairCofreeReader :: Monad m => Cofree (ReaderT (a, a) m) b -> ReaderT a m (Cofree (ReaderT a m) b)

-- | Given an initial value, we can convert a <a>FreeFoldM</a> of sucessive
--   <tt>(previous, current)</tt> pairs to a simple <a>FreeFoldM</a>.
unpairFoldFree :: Monad m => a -> FreeFoldM m (a, a) b -> FreeFoldM m a b
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Foldl.Free.FreeFoldM m a)
instance GHC.Base.Functor m => Data.Profunctor.Unsafe.Profunctor (Control.Foldl.Free.FreeFoldM m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Foldl.Free.FreeFoldM m a)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Foldl.Free.FreeFoldM m a)
instance GHC.Base.Applicative m => Data.Semigroupoid.Semigroupoid (Control.Foldl.Free.FreeFoldM m)


-- | This module provides a version of <a>FoldM</a> that only accepts
--   non-empty inputs
module Control.Foldl.Monadic.NonEmpty

-- | <a>FoldM</a> with a non-empty input
newtype FoldM1 m a b
FoldM1 :: ReaderT a (FoldM m a) b -> FoldM1 m a b
[runFoldM1] :: FoldM1 m a b -> ReaderT a (FoldM m a) b

-- | Apply a <a>FoldM1</a> to a <a>NonEmpty</a>
foldM1 :: Monad m => FoldM1 m a b -> NonEmpty a -> m b

-- | Convert a <a>FoldM1</a> to a <a>FoldM</a> that returns <a>Nothing</a>
--   if the input is empty.
fromFoldM1 :: Monad m => FoldM1 m a b -> FoldM m a (Maybe b)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Foldl.Monadic.NonEmpty.FoldM1 m a)
instance GHC.Base.Monad m => Data.Profunctor.Unsafe.Profunctor (Control.Foldl.Monadic.NonEmpty.FoldM1 m)


-- | This module provides a version of <tt>Foldl</tt> that can return early
module Control.Foldl.End

-- | <a>Fold</a> left or return an early result.
--   
--   Normal <a>Fold</a>s are strict and thus loop on infinite input:
--   
--   <pre>
--   λ&gt; F.fold F.head ([1..] :: [Int])
--   ^CInterrupted.
--   
--   λ&gt; foldE headE ([1..] :: [Int])
--   Just 1
--   (0.05 secs, 450,312 bytes)
--   </pre>
--   
--   Since <a>FoldE</a> returns early upon success, it can terminate on
--   infinite inputs.
--   
--   Can be composed in at least three ways!
--   
--   See the <a>Semigroupoid</a> instance for the first way: vertical
--   composition.
newtype FoldE a b
FoldE :: FoldM (Either b) a b -> FoldE a b
[runFoldE] :: FoldE a b -> FoldM (Either b) a b

-- | Unwrap and wrap the <a>FoldE</a> newtype
withFoldE :: (FoldM (Either b) a b -> FoldM (Either d) c d) -> FoldE a b -> FoldE c d

-- | TODO: compare performance to <a>fmap</a>
fmapAlternative :: (b -> c) -> FoldE a b -> FoldE a c

-- | <a>stepFoldM</a>, specialized to <a>FoldE</a>
stepFoldE :: a -> FoldE a b -> FoldE a b

-- | <a>unwrapFoldM</a> specialized to <a>FoldE</a>
unwrapFoldE :: FoldE a b -> Either b (FoldE a b)

-- | Take <tt>n</tt> and return a list
--   
--   <pre>
--   λ&gt; foldE (toFoldE F.list <a>o</a> takeE 3) [1..10]
--   [[1,2,3],[4,5,6],[7,8,9],[10]]
--   </pre>
takeE :: Int -> FoldE a [a]

-- | Drop <tt>n</tt> and return nothing
--   
--   <pre>
--   λ&gt; foldE (toFoldE F.list <a>o</a> (dropE 3 &gt;&gt; headE)) [1..10]
--   [Just 5,Just 9,Nothing]
--   </pre>
dropE :: Int -> FoldE a ()

-- | Take a single line (and toss its end, if it has one)
lineE :: FoldE Char String

-- | Return the first value and always fail if extracted earlier.
--   
--   I'm not really sure why the values are being duplicated.. but it's
--   probably because the first early return is assumed to have _not_
--   consumed the last value it reached..
--   
--   <pre>
--   λ&gt; foldE (toFoldE F.list <a>o</a> headE) [1..3]
--   [Just 1,Just 1,Just 2,Just 2,Just 3,Just 3,Nothing]
--   </pre>
headE :: FoldE a (Maybe a)

-- | Drop the first element provided or return `()` if extracted.
tailE :: FoldE a ()

-- | Return <a>Just</a> the last element or <a>Nothing</a>
lastE :: FoldE a (Maybe a)

-- | Returns early on `0`.
--   
--   Use <a>toFoldE</a> with the <a>product</a> from <tt>Control.Foldl</tt>
--   to multiply all elements.
--   
--   Note: will likely be less performant if you're unlikely to encounter
--   <tt>0</tt>.
product :: (Num a, Eq a) => FoldE a a

-- | Is the given value an element?
--   
--   This is preetty slow.. upwards of <tt>30x</tt> slower than <a>elem</a>
elem :: Eq a => a -> FoldE a Bool

-- | Wow, this is still pretty slow. (It's about <tt>70%</tt> faster with
--   lists of around <tt>2^20</tt> elements). Maybe if it's inlined and
--   -O3'd?
elem' :: Eq a => a -> FoldE a Bool

-- | Either return <a>Just</a> the first value matching the predicate or
--   <a>Nothing</a>.
find :: (a -> Bool) -> FoldE a (Maybe a)

-- | Either return <a>Just</a> the element at the given index (`0` at the
--   beginning of the <a>FoldE</a>) or <a>Nothing</a>.
index :: Int -> FoldE a (Maybe a)

-- | Return <a>Just</a> the value associated with the given key or
--   <a>Nothing</a>
lookup :: Eq a => a -> FoldE (a, b) (Maybe b)

-- | Returns early on <a>minBound</a>.
--   
--   Use <a>toFoldE</a> with the <a>minimum</a> for the general case.
--   
--   Likely to be much less performant if you don't expect to have many
--   <a>minBound</a>s in what you're folding.
minimum :: (Bounded a, Ord a) => FoldE a (Maybe a)

-- | Returns early on <a>maxBound</a>.
--   
--   Likely to be much less performant if you don't expect to have many
--   <a>maxBound</a>s in what you're folding.
maximum :: (Bounded a, Ord a) => FoldE a (Maybe a)

-- | <a>Just</a> the first index of the given value or <a>Nothing</a>
elemIndex :: Eq a => a -> FoldE a (Maybe Int)

-- | Find the first index for which the predicate returns <a>True</a>
findIndex :: (a -> Bool) -> FoldE a (Maybe Int)

-- | <a>index</a> for any <a>Integral</a>
genericIndex :: Integral i => i -> FoldE a (Maybe a)

-- | Assumes the input keys are monotonically increasing (<a>inc</a>)
lookupOrd :: Ord a => a -> FoldE (a, b) (Maybe b)

-- | Assumes the inputs are monotonically increasing (<a>inc</a>)
elemIndexOrd :: Ord a => a -> FoldE a (Maybe Int)

-- | Convert from a <a>FoldE</a> to a <a>Fold</a> by binding
--   (<a>&gt;&gt;=</a>) steps together and using <a>joinEither</a> on the
--   result.
fromFoldE :: FoldE a b -> Fold a b

-- | Never returns <a>Left</a>. `fromFoldE . toFoldE == id`
toFoldE :: Fold a b -> FoldE a b

-- | <a>foldE1</a> specialized to <a>Identity</a> and pre-applied for
--   convenience.
foldE1 :: FoldE a b -> a -> b

-- | Unfold the successive applications of a <a>FoldE</a> into a
--   <a>Cofree</a> <a>ReaderT</a>
toCofreeReader :: FoldE a b -> Cofree (ReaderT a (Either b)) b

-- | Convert a <a>FoldE</a> to a <a>FreeFoldM</a> using
--   <a>toCofreeReader</a>
foldEToFree :: FoldE a b -> FreeFoldM (Either b) a b

-- | Run a <a>FoldE</a> over a <a>Foldable</a>
foldE :: Foldable t => FoldE a b -> t a -> b

-- | Fold with the first fold until it returns <a>Left</a>, then feed its
--   input into the second fold and continue.
foldEThenE :: FoldE a b -> (b -> FoldE a c) -> FoldE a c

-- | Fold with the first <a>FoldE</a> until <a>Left</a>, then use its
--   result to construct the second fold and continue.
foldEThenFree :: FoldE a b -> (b -> FoldE a c) -> FreeFoldM (Either c) a c

-- | So, I was afraid that this wouldn't be more performant, but here it
--   is:
--   
--   <pre>
--   λ&gt; (foldE $ foldEThenE (takeE 3) (x -&gt; (length x +) <a>$</a> toFoldE F.sum)) $ [1..2^20]
--   (2.77 secs, 1,771,691,168 bytes)
--   
--   λ&gt; (foldE $ foldEThenE (takeE 3) (x -&gt; (length x +) <a>$</a> toFoldE F.sum)) $ [1..2^21]
--   (5.41 secs, 3,542,965,480 bytes)
--   
--   λ&gt; (foldE $ foldEThenERec (takeE 3) (x -&gt; (length x +) <a>$</a> toFoldE F.sum)) $ [1..2^20]
--   (0.68 secs, 857,335,424 bytes)
--   
--   λ&gt; (foldE $ foldEThenERec (takeE 3) (x -&gt; (length x +) <a>$</a> toFoldE F.sum)) $ [1..2^21]
--   (1.50 secs, 1,714,251,384 bytes)
--   </pre>
--   
--   Of course we'll have to wait for criterion benchmarks to really tell.
foldEThenERec :: FoldE a b -> (b -> FoldE a c) -> FoldE a c

-- | <a>foldEThenERec</a>, using <a>foldFreeThenFree</a> instead of
--   directly recursing.
--   
--   Preliminary tests show it may be a hair faster than
--   <a>foldEThenERec</a>, but we'll have to wait for criterion tests to
--   really tell.
foldEThenERec' :: FoldE a b -> (b -> FoldE a c) -> FoldE a c

-- | <a>foldEThenE</a>, but drop the first result
foldEThenE_ :: FoldE a b -> FoldE a c -> FoldE a c

-- | <a>foldEThenE</a>, but never fail with the second fold
foldEThen :: FoldE a b -> (b -> Fold a c) -> Fold a c

-- | <a>foldEThenE_</a>, but never fail on the second fold
foldEThen_ :: FoldE a b -> Fold a c -> Fold a c

-- | Ok, I think this is probably _not_ very efficient, but here goes:
--   
--   Example:
--   
--   <pre>
--   <a>peekLast</a> `(,)` :: <a>FoldE</a> a b -&gt; <a>FoldE</a> a (<a>Either</a> b (a, b))
--   <a>peekLast</a> `(,)` <a>head</a> :: <a>FoldE</a> a (<a>Either</a> (<a>Maybe</a> a) (a, <a>Maybe</a> a))
--   
--   λ&gt; peekLast headE (,) <a>foldE</a> [1..1]
--   Right (1,Just 1)
--   (0.02 secs, 549,328 bytes)
--   λ&gt; peekLast headE (,) <a>foldE</a> [1..10]
--   Right (1,Just 1)
--   (0.01 secs, 549,328 bytes)
--   </pre>
peekLast :: FoldE a b -> (a -> b -> c) -> FoldE a (Either b c)

-- | <a>peekLast</a>, discarding the result of the <a>FoldE</a>
peekLast_ :: FoldE a b -> (a -> c) -> FoldE a (Either b c)

-- | Given a fold over the results of cases for one or and maybe the
--   previous element, produce a fold over arbitrary inputs.
--   
--   <pre>
--   diffs :: Num a =&gt; FoldE a (Maybe a)
--   diffs = foldE2 ifOne ifMultiple _
--    where
--      ifOne = Just
--      ifMultiple = liftM2 (flip (-))
--   </pre>
--   
--   I've found it quite helpful for folding over pairs of elements.
foldE2 :: (a -> b) -> (a -> a -> b) -> FoldE b c -> FoldE a c

-- | <a>foldE2</a> using <a>foldFree2</a>
foldERec2 :: (a -> b) -> (a -> a -> b) -> FoldE b c -> FoldE a c

-- | Count the number of elements in the prefix that satisfy the predicate.
--   Should be equivalent to: <tt> <a>foldWhile</a> p <a>length</a> </tt>
countPrefixE :: Enum i => (a -> Bool) -> FoldE a i

-- | <ul>
--   <li>- We can use this with other combinators to build folding
--   parsers.</li>
--   </ul>
--   
--   Warning: composing two equivalent <a>takeWhileE</a>'s will diverge
takeWhileE :: (a -> Bool) -> FoldE a [a]

-- | Fold until the predicate fails
foldWhile :: (a -> Bool) -> Fold a b -> FoldE a b

-- | Fold until the predicate succeeds
foldUntil :: (a -> Bool) -> Fold a b -> FoldE a b

-- | Fold until the given fold returns early or the predicate fails
foldWhileE :: (a -> Bool) -> FoldE a b -> FoldE a b

-- | Fold until the given fold returns early or the predicate succeeds
foldUntilE :: (a -> Bool) -> FoldE a b -> FoldE a b

-- | If there's no previous element, equivalent to <a>foldWhile</a> on the
--   first predicate. If there's a previous element, then apply to it and
--   the current element:
--   
--   <pre>
--   predicate2 previous current
--   </pre>
foldWhile2 :: (a -> Bool) -> (a -> a -> Bool) -> Fold a b -> FoldE a b

-- | If there's no previous element, equivalent to <a>foldWhile</a> on the
--   first predicate. If there's a previous element, then we do:
--   
--   <pre>
--   predicate1 previous &amp;&amp; predicate2 current
--   </pre>
--   
--   I believe it can be more efficient than <a>foldWhile2</a>, but of
--   course your predicate has to be separable.
bifoldWhile :: (a -> Bool) -> (a -> Bool) -> Fold a b -> FoldE a b

-- | <a>foldWhile2</a>, but the <a>FoldE</a> can return early
foldWhileE2 :: (a -> Bool) -> (a -> a -> Bool) -> FoldE a b -> FoldE a b

-- | <a>bifoldWhile</a>, but the <a>FoldE</a> can return early
bifoldWhileE :: (a -> Bool) -> (a -> Bool) -> FoldE a b -> FoldE a b

-- | Skip while the predicate holds.
--   
--   I'm not sure whether this should have one of the types:
--   
--   <pre>
--   FoldE a a
--   FoldE a (Maybe a)
--   </pre>
--   
--   To allow it to return the element that the predicate fails on.
--   
--   Should be equivalent to:
--   
--   <pre>
--   void . foldWhile (pure ())
--   </pre>
skipWhile :: (a -> Bool) -> FoldE a ()

-- | Skip until the predicate holds
skipUntil :: (a -> Bool) -> FoldE a ()

-- | If the predicate passes, return the value. If folded over nothing,
--   return <a>Nothing</a>.
satisfyE :: (a -> Bool) -> FoldE a (Maybe a)

-- | Apply the function, ignoring the <a>Nothing</a>s
prefilterMaybe :: (a -> Maybe b) -> FoldE b c -> FoldE a c

-- | Convert a <a>FreeFoldM</a> to a <a>FoldE</a> using
--   <a>fromCofreeReader</a>
freeToFoldE :: FreeFoldM (Either b) a b -> FoldE a b

-- | <a>bifoldWhileE</a> implemented in terms of <tt>Cofree (ReaderT a
--   (Either b)) b</tt>.
bifoldWhileE' :: (a -> Bool) -> (a -> Bool) -> FoldE a b -> FoldE a b

-- | Since we can map over a single layer of a <a>Cofree</a>, returning
--   <a>Left</a> if the first predicate fails, we can apply the second
--   predicate using <a>foldWhileFreeE</a>.
--   
--   This avoids the need for <a>Maybe</a> in the state variable.
bifoldWhileFreeE :: (a -> Bool) -> (a -> Bool) -> Cofree (ReaderT a (Either b)) b -> Cofree (ReaderT a (Either b)) b

-- | See <a>foldWhileE</a>
foldWhileFreeE :: (a -> Bool) -> Cofree (ReaderT a (Either b)) b -> Cofree (ReaderT a (Either b)) b

-- | Are there any elements?
null :: FoldE a Bool

-- | Returns True if all elements are True, False otherwise
and :: FoldE Bool Bool

-- | Returns True if any elements are True, False otherwise
or :: FoldE Bool Bool

-- | Returns True if all elements satisfy the predicate, False otherwise
all :: (a -> Bool) -> FoldE a Bool

-- | Returns True if any elements satisfy the predicate, False otherwise
any :: (a -> Bool) -> FoldE a Bool

-- | Are all elements equal?
eq :: Eq a => FoldE a Bool

-- | Monotonically increasing
inc :: Ord a => FoldE a Bool

-- | Strictly increasing
inc' :: Ord a => FoldE a Bool

-- | Monotonically decreasing
dec :: Ord a => FoldE a Bool

-- | Strictly decreasing
dec' :: Ord a => FoldE a Bool
instance Data.Profunctor.Unsafe.Profunctor Control.Foldl.End.FoldE
instance GHC.Base.Functor (Control.Foldl.End.FoldE a)
instance Data.Functor.Extend.Extend (Control.Foldl.End.FoldE a)
instance Control.Comonad.Comonad (Control.Foldl.End.FoldE a)
instance GHC.Base.Applicative (Control.Foldl.End.FoldE a)
instance Data.Functor.Bind.Class.Apply (Control.Foldl.End.FoldE a)
instance Data.Functor.Bind.Class.Bind (Control.Foldl.End.FoldE a)
instance GHC.Base.Monad (Control.Foldl.End.FoldE a)
instance Control.Monad.Fix.MonadFix (Control.Foldl.End.FoldE a)
instance Control.Monad.Zip.MonadZip (Control.Foldl.End.FoldE a)
instance Data.Semigroupoid.Semigroupoid Control.Foldl.End.FoldE


-- | This module provides a version of <a>FoldM</a> that can return early
module Control.Foldl.Monadic.End

-- | <a>FoldM</a> left or return an early result
newtype FoldEM m a b
FoldEM :: FoldM (ExceptT b m) a b -> FoldEM m a b
[runFoldEM] :: FoldEM m a b -> FoldM (ExceptT b m) a b

-- | Unfold the successive applications of a <a>FoldEM</a> into a
--   <a>Cofree</a> <a>ReaderT</a> <a>ExceptT</a>
toCofreeReaderM :: Monad m => FoldEM m a b -> ExceptT b m (Cofree (ReaderT a (ExceptT b m)) b)

-- | Unfold a <a>FoldEM</a> into a <a>Cofree</a> <a>ReaderT</a>
toCofreeReaderT :: Monad m => FoldEM m a b -> ExceptT b m (Cofree (ReaderT a (ExceptT b m)) b)

-- | Convert a <a>FoldE</a> to a <a>FreeFoldM</a> using
--   <a>toCofreeReaderT</a>
foldEMToFree :: Monad m => FoldEM m a b -> FreeFoldM (ExceptT b m) a b

-- | using <a>foldFreeThenFreeM</a> instead of directly recursing
foldEMThenFree :: Monad m => FoldEM m a b -> (b -> FoldEM m a c) -> FreeFoldM (ExceptT c m) a c

-- | Using <a>FreeFoldM</a>, fold with the first <a>FoldEM</a> until it
--   returns, then use its result to generate the second <a>FoldEM</a> and
--   continue.
foldEMThenEMRec :: Monad m => FoldEM m a b -> (b -> FoldEM m a c) -> FoldEM m a c

-- | Lift a <a>FoldE</a> to a <a>FoldEM</a> by <a>return</a>ing the results
liftFoldE :: Monad m => FoldE a b -> FoldEM m a b

-- | We can convert a <a>FoldEM</a> to a <a>FoldM</a> (without the
--   <a>ExceptT</a> provided by <a>runFoldEM</a>) by including the
--   <a>Either</a> in the state and simply extracting the early return
--   value.
fromFoldEM :: Monad m => FoldEM m a b -> FoldM m a b

-- | We can lift a <a>FoldM</a> to a <a>FoldEM</a> without the need to
--   explicitly specify the required <a>ExceptT</a>, by using
--   <a>liftExceptT</a>.
liftFoldEM :: MonadError b m => FoldM m a b -> FoldEM m a b

-- | Lift an instance of <a>MonadError</a> to <a>ExceptT</a> using
--   <a>catchError</a>.
liftExceptT :: MonadError e m => m a -> ExceptT e m a

-- | Join the error and result terms of an <a>ExceptT</a>
joinExceptT :: Functor m => ExceptT a m a -> m a
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Foldl.Monadic.End.FoldEM m a)
instance GHC.Base.Monad m => Data.Profunctor.Unsafe.Profunctor (Control.Foldl.Monadic.End.FoldEM m)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Apply (Control.Foldl.Monadic.End.FoldEM m a)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Foldl.Monadic.End.FoldEM m a)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Foldl.Monadic.End.FoldEM m a)
instance GHC.Base.Monad m => Data.Functor.Extend.Extend (Control.Foldl.Monadic.End.FoldEM m a)
instance GHC.Base.Monad m => Data.Semigroupoid.Semigroupoid (Control.Foldl.Monadic.End.FoldEM m)
instance Control.Monad.Fail.MonadFail m => Control.Category.Category (Control.Foldl.Monadic.End.FoldEM m)


-- | This module provides a version of <a>FoldEM</a> that only accepts
--   non-empty inputs
module Control.Foldl.Monadic.End.NonEmpty

-- | <a>FoldEM</a> with a non-empty input.
--   
--   <a>FoldEM1</a>'s have a <tt>Category</tt> instance, provided by
--   succeeding early on the given value.
newtype FoldEM1 m a b
FoldEM1 :: ReaderT a (FoldEM m a) b -> FoldEM1 m a b
[runFoldEM1] :: FoldEM1 m a b -> ReaderT a (FoldEM m a) b
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Foldl.Monadic.End.NonEmpty.FoldEM1 m a)
instance GHC.Base.Monad m => Data.Profunctor.Unsafe.Profunctor (Control.Foldl.Monadic.End.NonEmpty.FoldEM1 m)


-- | This module provides a version of <a>FoldE</a> for strictly non-empty
--   inputs
module Control.Foldl.End.NonEmpty

-- | <a>FoldE1</a>'s have a <a>Category</a> instance, provided by
--   succeeding early on the given value.
newtype FoldE1 a b
FoldE1 :: ReaderT a (FoldE a) b -> FoldE1 a b
[runFoldE1] :: FoldE1 a b -> ReaderT a (FoldE a) b

-- | Convert a <a>FoldE1</a> to an unwrapped <a>FreeFoldM</a>
foldE1ToFreeFold :: FoldE1 a b -> ReaderT a (Either b) (FreeFoldM (Either b) a b)

-- | Convert an unwrapped <a>FreeFoldM</a> to a <a>FoldE1</a>
freeFoldToFoldE1 :: ReaderT a (Either b) (FreeFoldM (Either b) a b) -> FoldE1 a b

-- | <tt>o</tt>, but the first argument is a <a>FoldE1</a>
appendFoldE1 :: FoldE1 b c -> FoldE a b -> FoldE a c

-- | <a>undefined</a>
appendFreeE1 :: ReaderT b (Either c) (FreeFoldM (Either c) b c) -> FreeFoldM (Either b) a b -> FreeFoldM (Either c) a c

-- | <a>undefined</a>
appendFreeE :: FreeFoldM (Either c) b c -> FreeFoldM (Either b) a b -> FreeFoldM (Either c) a c
instance GHC.Base.Monad (Control.Foldl.End.NonEmpty.FoldE1 a)
instance GHC.Base.Applicative (Control.Foldl.End.NonEmpty.FoldE1 a)
instance GHC.Base.Functor (Control.Foldl.End.NonEmpty.FoldE1 a)
instance Data.Profunctor.Unsafe.Profunctor Control.Foldl.End.NonEmpty.FoldE1
instance Control.Category.Category Control.Foldl.End.NonEmpty.FoldE1


-- | This module provides a definition of a free <a>Foldable</a> container
--   in terms of <a>Fold</a>, using existential types.
module Data.Foldable.Free

-- | A free <a>Foldable</a> container
newtype FoldableFree a
FoldableFree :: forall x. Fold a x -> x -> FoldableFree a
[runFoldableFree] :: FoldableFree a -> forall x. Fold a x -> x

-- | The first element of a <a>FoldableFree</a>, if it exists
head :: FoldableFree a -> Maybe a

-- | All but the first element of a <a>FoldableFree</a> if it's
--   non-<a>null</a>. Otherwise, returns <a>empty</a>
tail :: FoldableFree a -> FoldableFree a

-- | Return <a>Just</a> the <a>head</a> and <a>tail</a> or <a>Nothing</a>
--   if <a>null</a>
uncons :: FoldableFree a -> Maybe (a, FoldableFree a)

-- | Prepend an element to a <a>FoldableFree</a>
--   
--   Failing implementations:
--   
--   <pre>
--   cons x FoldableFree {..} = runFoldableFree $ stepFold x foldableFree
--   
--   
--   cons' x FoldableFree{..} = runFoldableFree $
--     Fold (flip cons') (return x) id
--   
--   λ&gt; cons' () [()]
--   FoldableFree *** Exception: stack overflow
--   </pre>
cons :: a -> FoldableFree a -> FoldableFree a

-- | <a>Fold</a> into a <a>FoldableFree</a>
foldableFree :: Fold a (FoldableFree a)

-- | Convert any <a>Foldable</a> into a <a>FoldableFree</a>.
--   
--   <pre>
--   <a>toList</a> . <a>toFoldableFree</a> == <a>toList</a>
--   </pre>
toFoldableFree :: Foldable t => t a -> FoldableFree a

-- | Uses <a>tabulateFold</a> and <a>indexFold</a>
distributeFold :: Functor f => f (Fold a b) -> Fold a (f b)

-- | Apply a strict left <a>Fold</a> to a <a>Foldable</a> container,
--   right-to-left
foldR :: Foldable f => Fold a b -> f a -> b

-- | We build <a>tabulate</a> by folding over the input values and feeding
--   them to the <a>FoldableFree</a>.
--   
--   <pre>
--   <a>index</a> == <a>foldR</a>
--   
--   instance Representable (Fold a) where
--     type Rep (Fold a) = FoldableFree a
--   </pre>
indexFold :: Fold a b -> FoldableFree a -> b

-- | Tabulate a <a>Fold</a> by building up successive <a>FoldableFree</a>s.
--   
--   Quick benchmark:
--   
--   <pre>
--   λ&gt; F.fold ((tabulateFold . indexFold) (F.lastN 3)) ([1..2^12] :: [Int])
--   [4094,4095,4096]
--   (1.67 secs, 1,952,032,256 bytes)
--   
--   λ&gt; F.fold (F.lastN 3) ([1..2^12] :: [Int])
--   [4094,4095,4096]
--   (0.01 secs, 1,632,784 bytes)
--   </pre>
tabulateFold :: (FoldableFree a -> b) -> Fold a b

-- | If this returns anything other than:
--   
--   <pre>
--   <a>Just</a> "It didn't diverge!"
--   </pre>
--   
--   Then we have a bug.
--   
--   The bug it's designed to find is: either <a>tabulateFold</a> or
--   <a>indexFold</a> is non-productive until reaching the end of the
--   input. In this case, the input is unlimited while the <a>Fold</a> can
--   return upon reaching the first element.
--   
--   And.. it's not returning..
--   
--   <pre>
--   λ&gt; divergenceCheck
--   ^CInterrupted.
--   </pre>
--   
--   Well we have a bug..
--   
--   Now I'm wondering whether that's a feature.. of the strict
--   implementaton of <a>fold</a>..
--   
--   It's a feature, regular folds also diverge:
--   
--   <pre>
--   λ&gt; F.fold F.head [1..]
--   ^CInterrupted.
--   </pre>
--   
--   Even using <tt>generalizeMaybe</tt> diverges:
--   
--   <pre>
--   λ&gt; F.foldM (generalizeMaybe F.head) [1..] :: MaybeT Identity Int
--   MaybeT (Identity ^CInterrupted.
--   </pre>
divergenceCheck :: Maybe String
instance GHC.Exts.IsList (Data.Foldable.Free.FoldableFree a)
instance Data.Functor.Classes.Eq1 Data.Foldable.Free.FoldableFree
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Foldable.Free.FoldableFree a)
instance Data.Functor.Classes.Ord1 Data.Foldable.Free.FoldableFree
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Foldable.Free.FoldableFree a)
instance Data.Functor.Classes.Show1 Data.Foldable.Free.FoldableFree
instance GHC.Show.Show a => GHC.Show.Show (Data.Foldable.Free.FoldableFree a)
instance Data.Functor.Classes.Read1 Data.Foldable.Free.FoldableFree
instance GHC.Read.Read a => GHC.Read.Read (Data.Foldable.Free.FoldableFree a)
instance GHC.Base.Semigroup (Data.Foldable.Free.FoldableFree a)
instance GHC.Base.Monoid (Data.Foldable.Free.FoldableFree a)
instance GHC.Base.Functor Data.Foldable.Free.FoldableFree
instance Data.Foldable.Foldable Data.Foldable.Free.FoldableFree
instance Data.Traversable.Traversable Data.Foldable.Free.FoldableFree
instance GHC.Base.Applicative Data.Foldable.Free.FoldableFree
instance GHC.Base.Alternative Data.Foldable.Free.FoldableFree
instance GHC.Base.Monad Data.Foldable.Free.FoldableFree
instance GHC.Base.MonadPlus Data.Foldable.Free.FoldableFree
instance Control.Monad.Fail.MonadFail Data.Foldable.Free.FoldableFree
instance Control.Monad.Fix.MonadFix Data.Foldable.Free.FoldableFree
instance Control.Monad.Zip.MonadZip Data.Foldable.Free.FoldableFree
instance Data.Functor.Rep.Representable (Control.Foldl.Fold a)
instance Data.Distributive.Distributive (Control.Foldl.Fold a)


-- | This module provides a <a>Fold</a> that returns a stream of outputs
--   
--   Note that it's a <a>Category</a>.
module Control.Foldls

-- | A <a>Fold</a> returning a stream of outputs.
--   
--   <pre>
--   <a>Folds</a> a b = <a>Fold</a> a (<a>Rep</a> (<a>Fold</a> b))
--   <a>Folds</a> a b = <a>Fold</a> a (<a>FoldableFree</a> b)
--   
--   </pre>
newtype Folds a b
Folds :: Fold a (FoldableFree b) -> Folds a b
[runFolds] :: Folds a b -> Fold a (FoldableFree b)

-- | <a>undefined</a>
readerToFolds :: (forall x. FoldM (ReaderT x (Fold b)) a x) -> Folds a b

-- | <a>undefined</a>
foldsToReader :: Folds a b -> (forall x. FoldM (ReaderT x (Fold b)) a x)

-- | Simply <tt>(<a>return</a> :: b -&gt; <a>FoldableFree</a> b)</tt> the
--   result of a <a>Fold</a>
foldToFolds :: Fold a b -> Folds a b
instance GHC.Base.Functor (Control.Foldls.Folds a)
instance Data.Semigroupoid.Semigroupoid Control.Foldls.Folds
instance Control.Category.Category Control.Foldls.Folds


-- | This module provides a definition of a free <a>Foldable</a> container
--   in terms of <a>Fold</a>, using existential types in a Church encoding.
module Data.Foldable.Free.Church

-- | Church encoding of a free <a>Foldable</a> container
newtype FoldableF a
FoldableF :: forall x y. (x -> a -> x) -> x -> (x -> y) -> y -> FoldableF a
[runFoldableF] :: FoldableF a -> forall x y. (x -> a -> x) -> x -> (x -> y) -> y

-- | The first element of a <tt>FoldableFree</tt>, if it exists
head :: FoldableF a -> Maybe a

-- | All but the first element of a <tt>FoldableFree</tt> if it's
--   non-<a>null</a>. Otherwise, returns <a>empty</a>
tail :: FoldableF a -> FoldableF a

-- | Return <a>Just</a> the <a>head</a> and <a>tail</a> or <a>Nothing</a>
--   if <a>null</a>
uncons :: FoldableF a -> Maybe (a, FoldableF a)

-- | Prepend an element to a <tt>FoldableFree</tt>
cons :: a -> FoldableF a -> FoldableF a

-- | Convert any <a>Foldable</a> into a <a>FoldableF</a>.
--   
--   <pre>
--   <a>toList</a> . <a>toFoldableF</a> == <a>toList</a>
--   </pre>
toFoldableF :: Foldable t => t a -> FoldableF a

-- | Strict <a>toFoldableF</a>
toFoldableF' :: Foldable t => t a -> FoldableF a

-- | <a>Fold</a> into a <tt>FoldableFree</tt>
foldableF :: Fold a (FoldableF a)

-- | Uses <a>tabulateFold</a> and <a>indexFold</a>
distributeFold :: Functor f => f (Fold a b) -> Fold a (f b)

-- | Index a <a>Fold</a> using a <a>FoldableF</a>
indexFold :: Fold a b -> FoldableF a -> b

-- | Tabulate a <a>Fold</a> using a <a>FoldableF</a>
tabulateFold :: (FoldableF a -> b) -> Fold a b
instance GHC.Base.Functor Data.Foldable.Free.Church.FoldableF
instance Data.Foldable.Foldable Data.Foldable.Free.Church.FoldableF
instance Data.Functor.Classes.Eq1 Data.Foldable.Free.Church.FoldableF
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Foldable.Free.Church.FoldableF a)
instance Data.Functor.Classes.Ord1 Data.Foldable.Free.Church.FoldableF
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Foldable.Free.Church.FoldableF a)
instance Data.Functor.Classes.Show1 Data.Foldable.Free.Church.FoldableF
instance GHC.Show.Show a => GHC.Show.Show (Data.Foldable.Free.Church.FoldableF a)
instance Data.Functor.Classes.Read1 Data.Foldable.Free.Church.FoldableF
instance GHC.Read.Read a => GHC.Read.Read (Data.Foldable.Free.Church.FoldableF a)
instance GHC.Base.Semigroup (Data.Foldable.Free.Church.FoldableF a)
instance GHC.Base.Monoid (Data.Foldable.Free.Church.FoldableF a)
instance Data.Traversable.Traversable Data.Foldable.Free.Church.FoldableF
instance GHC.Base.Applicative Data.Foldable.Free.Church.FoldableF
instance GHC.Base.Alternative Data.Foldable.Free.Church.FoldableF
instance GHC.Base.Monad Data.Foldable.Free.Church.FoldableF
instance GHC.Base.MonadPlus Data.Foldable.Free.Church.FoldableF
instance Control.Monad.Fail.MonadFail Data.Foldable.Free.Church.FoldableF
instance Control.Monad.Fix.MonadFix Data.Foldable.Free.Church.FoldableF
instance Control.Monad.Zip.MonadZip Data.Foldable.Free.Church.FoldableF


-- | This module provides an implementation of a free <tt>FoldableM1</tt>
--   in terms of <a>FoldM1</a>.
module Data.Foldable.Monadic.NonEmpty.Free

-- | Encoding of a free <tt>FoldableM1</tt>
newtype FoldableFreeM1 m a
FoldableFreeM1 :: forall x. FoldM1 m a x -> x -> FoldableFreeM1 m a
[runFoldableFreeM1] :: FoldableFreeM1 m a -> forall x. FoldM1 m a x -> x


-- | This module provides a <a>FoldM1</a> that returns a non-empty monadic
--   stream of outputs
module Control.Foldls.Monadic.NonEmpty

-- | A <a>FoldM1</a> returning a non-empty monadic stream of outputs
newtype FoldsM1 m a b
FoldsM1 :: FoldM1 m a (FoldableFreeM1 m b) -> FoldsM1 m a b
[runFoldsM] :: FoldsM1 m a b -> FoldM1 m a (FoldableFreeM1 m b)


-- | This module provides a <a>FoldEM1</a> that returns a non-empty monadic
--   stream of outputs
module Control.Foldls.Monadic.End.NonEmpty

-- | A <a>FoldEM1</a> returning a monadic stream of outputs
newtype FoldsEM1 m a b
FoldsEM1 :: FoldEM1 m a (FoldableFreeM1 (ExceptT b m) b) -> FoldsEM1 m a b
[runFoldsEM] :: FoldsEM1 m a b -> FoldEM1 m a (FoldableFreeM1 (ExceptT b m) b)


-- | This module provides an implementation of a free <tt>FoldableM1</tt>
--   with a Church encoding.
module Data.Foldable.Monadic.NonEmpty.Free.Church

-- | Church encoding of a free <tt>FoldableM</tt>
newtype FoldableM1F m a
FoldableM1F :: forall x y. a -> (x -> a -> m x) -> x -> (x -> m y) -> m y -> FoldableM1F m a
[runFoldableM1F] :: FoldableM1F m a -> forall x y. a -> (x -> a -> m x) -> x -> (x -> m y) -> m y


-- | This module provides an implementation for a free <tt>Foldable1</tt>
--   in terms of <a>Fold1</a>.
module Data.Foldable.NonEmpty.Free

-- | Encoding of a free <tt>Foldable1</tt>
newtype FoldableFree1 a
FoldableFree1 :: forall x. Fold1 a x -> x -> FoldableFree1 a
[runFoldableFree1] :: FoldableFree1 a -> forall x. Fold1 a x -> x


-- | This module provides a <a>Fold1</a> that returns a non-empty stream of
--   outputs
module Control.Foldls.NonEmpty

-- | A <a>Fold1</a> returning a non-empty stream of outputs
newtype Folds1 a b
Folds1 :: Fold1 a (FoldableFree1 b) -> Folds1 a b
[runFolds1] :: Folds1 a b -> Fold1 a (FoldableFree1 b)


-- | This module provides an implementation for a free <tt>Foldable1</tt>
--   using a Church encoding.
module Data.Foldable.NonEmpty.Free.Church

-- | Church encoding of a free <tt>Foldable1</tt>
newtype Foldable1F a
Foldable1F :: forall x y. a -> (x -> a -> x) -> x -> (x -> y) -> y -> Foldable1F a
[runFoldable1F] :: Foldable1F a -> forall x y. a -> (x -> a -> x) -> x -> (x -> y) -> y


-- | This module provides a <a>Functor</a> transformer that is guaranteed
--   to be non-empty by construction.
module Data.Functor.NonEmpty

-- | A <a>Functor</a> with a guranteed element, making it non-empty
newtype NonEmptyT f a
NonEmptyT :: (a, f a) -> NonEmptyT f a
[runNonEmptyT] :: NonEmptyT f a -> (a, f a)

-- | Extract the guraranteed value from a <a>NonEmptyT</a>
extractNonEmptyT :: NonEmptyT f a -> a

-- | Extract all but the guaranteed value from a <a>NonEmptyT</a>
dropNonEmptyT :: NonEmptyT f a -> f a

-- | Convert to <a>NonEmpty</a>
toNonEmpty :: Foldable f => NonEmptyT f a -> NonEmpty a

-- | Convert from <a>NonEmpty</a>
fromNonEmpty :: NonEmpty a -> NonEmptyT [] a
instance GHC.Generics.Generic (Data.Functor.NonEmpty.NonEmptyT f a)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup (f a)) => GHC.Base.Semigroup (Data.Functor.NonEmpty.NonEmptyT f a)
instance (GHC.Base.Monoid a, GHC.Base.Monoid (f a)) => GHC.Base.Monoid (Data.Functor.NonEmpty.NonEmptyT f a)
instance GHC.Generics.Generic1 f => GHC.Generics.Generic1 (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Data.Functor.NonEmpty.NonEmptyT f)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.NonEmpty.NonEmptyT f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Data.Functor.NonEmpty.NonEmptyT f)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.NonEmpty.NonEmptyT f a)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Data.Functor.NonEmpty.NonEmptyT f)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.NonEmpty.NonEmptyT f a)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Data.Functor.NonEmpty.NonEmptyT f)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.NonEmpty.NonEmptyT f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.NonEmpty.NonEmptyT f)
instance GHC.Base.Alternative f => GHC.Base.Applicative (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Functor.Extend.Extend f => Control.Comonad.Comonad (Data.Functor.NonEmpty.NonEmptyT f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Alternative f) => Data.Functor.Bind.Class.Bind (Data.Functor.NonEmpty.NonEmptyT f)
instance (GHC.Base.Monad f, GHC.Base.Alternative f) => GHC.Base.Monad (Data.Functor.NonEmpty.NonEmptyT f)
instance (Control.Monad.Zip.MonadZip f, GHC.Base.Alternative f) => Control.Monad.Zip.MonadZip (Data.Functor.NonEmpty.NonEmptyT f)
instance (Control.Monad.Fix.MonadFix f, GHC.Base.Alternative f) => Control.Monad.Fix.MonadFix (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Distributive.Distributive f => Data.Distributive.Distributive (Data.Functor.NonEmpty.NonEmptyT f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Data.Functor.NonEmpty.NonEmptyT f)


-- | This module provides a class for folding over non-empty containers,
--   i.e. a subclass of <a>Foldable</a>.
module Data.Foldable.NonEmpty

-- | Those data-types that can be folded over and are non-empty
class Foldable t => Foldable1 t

-- | Apply a pure strict left fold to a non-empty collection
fold1 :: Foldable1 t => Fold1 a b -> t a -> b

-- | Apply a <a>Monad</a>ic strict left fold to a non-empty collection
foldM1 :: (Foldable1 t, Monad m) => FoldM1 m a b -> t a -> m b

-- | The first element of a non-empty collection
head1 :: Foldable1 t => t a -> a

-- | The last element of a non-empty collection
last1 :: Foldable1 t => t a -> a

-- | Return <tt>empty</tt> unless the container being folded over is
--   non-empty. Otherwise behaves like <a>fold1</a>.
--   
--   <a>undefined</a>
pureFold1Maybe :: Foldable t => Fold1 a b -> t a -> MaybeT m b

-- | Return <tt>empty</tt> unless the container being folded over is
--   non-empty. Otherwise behaves like <a>foldM1</a>.
--   
--   <a>undefined</a>
impureFold1Maybe :: Foldable t => Fold1 a b -> t a -> MaybeT m b

-- | Convert a <a>FoldM</a> to a <a>Fold</a> that returns a <a>Monad</a>ic
--   value
asPure :: Monad m => FoldM m a b -> Fold a (m b)

-- | Convert a <a>FoldM1</a> to a <a>Fold1</a> that returns a
--   <a>Monad</a>ic value
asPure1 :: Monad m => FoldM1 m a b -> Fold1 a (m b)

-- | Convert a <a>FoldEM</a> to a <a>FoldE</a> that returns a
--   <a>Monad</a>ic value
--   
--   <a>undefined</a>
asPureE :: Monad m => FoldEM m a b -> FoldE a (m b)

-- | Convert a <a>FoldEM1</a> to a <a>FoldE1</a> that returns a
--   <a>Monad</a>ic value
--   
--   <a>undefined</a>
asPureE1 :: Monad m => FoldEM1 m a b -> FoldE1 a (m b)
instance Data.Foldable.NonEmpty.Foldable1 GHC.Base.NonEmpty
instance Data.Foldable.Foldable t => Data.Foldable.NonEmpty.Foldable1 (Data.Functor.NonEmpty.NonEmptyT t)
instance Data.Foldable.Foldable f => Data.Foldable.NonEmpty.Foldable1 (Control.Comonad.Cofree.Cofree f)
instance Data.Foldable.NonEmpty.Foldable1 f => Data.Foldable.NonEmpty.Foldable1 (Control.Monad.Free.Free f)


-- | This module provides a class for types you can fold over with a
--   <a>Monad</a>ic result.
module Data.Foldable.Monadic

-- | A relatively minimal implementation
class Monad m => FoldableM m (t :: * -> *) | t -> m
pureFold :: FoldableM m t => Fold a b -> t a -> m b
impureFold :: FoldableM m t => FoldM m a b -> t a -> m b

-- | Convert to <a>ListT</a>
toListT :: FoldableM m t => t a -> ListT m a

-- | Fold into a <a>ListT</a> (migrate to Utils)
listT :: Monad m => Fold a (ListT m a)

-- | <a>foldMap</a> for a <a>FoldableM</a>
pureFoldMap :: (FoldableM m t, Monoid w) => (a -> w) -> t a -> m w

-- | <a>pureFoldMap</a>, where the function returns a monadic result
impureFoldMap :: (FoldableM m t, Monoid w) => (a -> m w) -> t a -> m w

-- | Apply all of the elements in a <a>FoldableM</a> to a <a>Fold</a>,
--   retaining the partial result.
stepsFold :: FoldableM m t => Fold a b -> t a -> m (Fold a b)

-- | Apply all of the elements in a <a>FoldableM</a> to a <a>FoldM</a>,
--   retaining the partial result.
stepsFoldM :: FoldableM m t => FoldM m a b -> t a -> m (FoldM m a b)

-- | Fold over the inner argument using the <a>FoldableM</a> instance
innerFold :: FoldableM m t => Fold a b -> FoldM m (t a) b

-- | Fold over the inner argument using the <a>FoldableM</a> instance
innerFoldM :: FoldableM m t => FoldM m a b -> FoldM m (t a) b

-- | Deconstruct a <a>FreeF</a> like <a>either</a>
freeF :: (a -> c) -> (f b -> c) -> FreeF f a b -> c

-- | The first of three
fst3 :: (a, b, c) -> a

-- | TODO:
--   
--   <pre>
--   instance (FoldableM m f, FoldableM m g) =&gt; FoldableM m (f :.: g)
--   instance (FoldableM m f, FoldableM m g) =&gt; FoldableM m (f :*: g)
--   instance (FoldableM m f, FoldableM m g) =&gt; FoldableM m (f :+: g)
--   
--   newtype WrappedFoldableT t m a = WrappedFoldableT { runWrappedFoldableT :: m (t a) }
--   instance (Monad m, Foldable t) =&gt; FoldableM m (WrappedFoldable t m)
--   
--   instance (PrimMonad m, MVector v a) =&gt; FoldableM m (v (PrimState m) :&gt;- a) where
--     pureFold = pureFold . mstream
--   
--   instance Monad m =&gt; FoldableM m (Stream m) where
--     _ -- This is where FoldableM shines :D
--   </pre>
todo :: ()
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (ListT.ListT m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Accum.AccumT w m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Identity.IdentityT m)
instance (GHC.Base.Monad m, GHC.Base.Monoid r, GHC.Base.Monoid s) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid r, GHC.Base.Monoid s) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monad m, GHC.Base.Monoid s) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid s) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.State.Strict.StateT s m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Foldable.Monadic.FoldableM m f => Data.Foldable.Monadic.FoldableM m (Control.Comonad.Cofree.Cofree f)
instance Data.Foldable.Monadic.FoldableM m f => Data.Foldable.Monadic.FoldableM m (Control.Comonad.Trans.Cofree.CofreeT f m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Comonad.Trans.Coiter.CoiterT m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Free.Free m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Free.Ap.Free m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Free.Church.F m)
instance Data.Foldable.Monadic.FoldableM m f => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Free.FreeT f m)
instance (Data.Foldable.Monadic.FoldableM m f, GHC.Base.Functor f) => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Free.Church.FT f m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Control.Monad.Trans.Iter.IterT m)
instance Data.Foldable.Monadic.FoldableM m f => Data.Foldable.Monadic.FoldableM m (Data.Functor.NonEmpty.NonEmptyT f)


-- | This module provides a class for <a>FoldableM</a>, restricted to
--   data-types that are non-empty up to the <a>Monad</a> being non-empty.
module Data.Foldable.Monadic.NonEmpty

-- | <a>FoldableM</a> for non-empty containers
class FoldableM m t => FoldableM1 m t | t -> m
pureFold1 :: FoldableM1 m t => Fold1 a b -> t a -> m b
impureFold1 :: FoldableM1 m t => FoldM1 m a b -> t a -> m b

-- | Return <tt>empty</tt> unless the container being folded over is
--   non-empty. Otherwise behaves like <a>pureFold</a>.
pureFold1MaybeT :: FoldableM m t => Fold1 a b -> t a -> MaybeT m b

-- | Return <tt>empty</tt> unless the container being folded over is
--   non-empty. Otherwise behaves like <a>impureFold</a>.
impureFold1MaybeT :: FoldableM m t => FoldM1 m a b -> t a -> MaybeT m b


-- | This module provides an implementation of a free <a>FoldableM</a> in
--   terms of <a>FoldM</a>, using a Church representation.
module Data.Foldable.Monadic.Free.Church

-- | Church encoding of a free <a>Foldable</a> container
newtype FoldableFM m a
FoldableFM :: forall x y. (x -> a -> m x) -> x -> (x -> m y) -> m y -> FoldableFM m a
[runFoldableFM] :: FoldableFM m a -> forall x y. (x -> a -> m x) -> x -> (x -> m y) -> m y

-- | The first element of a <a>FoldableFM</a>, if it exists
head :: Monad m => FoldableFM m a -> MaybeT m a

-- | All but the first element of a <a>FoldableFM</a> if it's
--   non-<a>null</a>. Otherwise, returns <a>empty</a>
tail :: Monad m => FoldableFM m a -> FoldableFM m a

-- | Return <a>Just</a> the <a>head</a> and <a>tail</a> or <a>Nothing</a>
--   if <a>null</a>
uncons :: Monad m => FoldableFM m a -> MaybeT m (a, FoldableFM m a)

-- | Prepend an element to a <a>FoldableFM</a>
cons :: Monad m => a -> FoldableFM m a -> FoldableFM m a

-- | Prepend an element to a <a>FoldableFM</a> with the monadic effects
--   exposed <tt>consM = mappend . return</tt>
consM :: Monad m => a -> FoldableFM m a -> m (FoldableFM m a)

-- | <a>FoldM</a> into a <a>FoldableFM</a>
foldableFM :: Monad m => FoldM m a (FoldableFM m a)

-- | Convert any <a>FoldableM</a> into a <a>FoldableFM</a>.
--   
--   <pre>
--   <a>toListT</a> . <a>toFoldableFM</a> == <a>toListT</a>
--   </pre>
toFoldableFM :: FoldableM m t => t a -> FoldableFM m a

-- | Sequence the side effects and then collect the values using
--   <a>consM</a>
fromCofree :: Monad m => Cofree m a -> FoldableFM m a

-- | Convert to a <a>Cofree</a> <a>MaybeT</a>
toCofreeMaybe :: Monad m => FoldableFM m a -> MaybeT m (Cofree (MaybeT m) a)

-- | Convert a <a>Cofree</a> <a>MaybeT</a> to a <tt>FoldableFreeM</tt>
fromCofreeMaybe :: Monad m => Cofree (MaybeT m) a -> FoldableFM m a

-- | Fold monadically into a <a>Cofree</a> <a>MaybeT</a>
cofreeMaybeT :: Monad m => FoldM m a (Maybe (Cofree (MaybeT m) a))

-- | Wrap a layer of monadic context into a <a>FoldableFM</a>
wrapFoldableFM :: Monad m => m (FoldableFM m a) -> FoldableFM m a

-- | Apply <a>wrapFoldableFM</a> and replace <a>Nothing</a> with
--   <a>empty</a>
wrapMaybeT :: Monad m => MaybeT m (FoldableFM m a) -> FoldableFM m a

-- | Unwrap a layer of monadic context from a <a>FoldableFM</a>
unwrapFoldableFM :: Monad m => FoldableFM m a -> m (FoldableFM m a)

-- | Uses <a>tabulateFoldM</a> and <a>indexFoldM</a>. See
--   <a>Distributive</a>.
distributeFoldM :: (Monad m, Distributive m, Functor f) => f (FoldM m a b) -> FoldM m a (f b)

-- | Index a <a>FoldM</a> using a <a>FoldableFM</a>. See
--   <tt>Representable</tt>.
indexFoldM :: Monad m => FoldM m a b -> FoldableFM m a -> m b

-- | Tabulate a <a>FoldM</a> by building up successive <a>FoldableFM</a>s
tabulateFoldM :: Monad m => (FoldableFM m a -> m b) -> FoldM m a b

-- | Wrap a layer of the <a>Monad</a>ic context into a <a>FoldM</a>. See
--   <tt>MonadFree</tt>
wrapFoldM :: Monad m => m (FoldM m a b) -> FoldM m a b
instance GHC.Base.Monad m => GHC.Base.Semigroup (Data.Foldable.Monadic.Free.Church.FoldableFM m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Data.Foldable.Monadic.Free.Church.FoldableFM m a)
instance (GHC.Base.Monad m, Data.Foldable.Foldable m) => Data.Foldable.Foldable (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance (GHC.Base.Monad m, Data.Traversable.Traversable m) => Data.Traversable.Traversable (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Functor (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => Control.Monad.Fix.MonadFix (Data.Foldable.Monadic.Free.Church.FoldableFM m)
instance GHC.Base.Monad m => Control.Monad.Zip.MonadZip (Data.Foldable.Monadic.Free.Church.FoldableFM m)


-- | This module provides an implementation of a free <a>FoldableM</a> in
--   terms of <a>FoldM</a>.
module Data.Foldable.Monadic.Free

-- | A free <a>FoldableM</a> container
newtype FoldableFreeM m a
FoldableFreeM :: forall x. FoldM m a x -> m x -> FoldableFreeM m a
[runFoldableFreeM] :: FoldableFreeM m a -> forall x. FoldM m a x -> m x

-- | The first element of a <a>FoldableFreeM</a>, if it exists
head :: Monad m => FoldableFreeM m a -> MaybeT m a

-- | All but the first element of a <a>FoldableFreeM</a> if it's
--   non-<a>null</a>. Otherwise, returns <a>empty</a>
tail :: Monad m => FoldableFreeM m a -> FoldableFreeM m a

-- | Return <a>Just</a> the <a>head</a> and <a>tail</a> or <a>Nothing</a>
--   if <a>null</a>
uncons :: Monad m => FoldableFreeM m a -> MaybeT m (a, FoldableFreeM m a)

-- | Prepend an element to a <a>FoldableFreeM</a>
cons :: Monad m => a -> FoldableFreeM m a -> FoldableFreeM m a

-- | Prepend an element to a <a>FoldableFreeM</a> with the monadic effects
--   exposed
consM :: Monad m => a -> FoldableFreeM m a -> m (FoldableFreeM m a)

-- | <a>FoldM</a> into a <a>FoldableFreeM</a>
foldableFreeM :: Monad m => FoldM m a (FoldableFreeM m a)

-- | Convert any <a>FoldableM</a> into a <a>FoldableFreeM</a>.
--   
--   <pre>
--   <a>toListT</a> . <a>toFoldableFreeM</a> == <a>toListT</a>
--   </pre>
toFoldableFreeM :: FoldableM m t => t a -> FoldableFreeM m a

-- | Sequence the side effects and then collect the values using
--   <a>consM</a>
fromCofree :: Monad m => Cofree m a -> FoldableFreeM m a

-- | Convert to a <a>Cofree</a> <a>MaybeT</a>
toCofreeMaybe :: Monad m => FoldableFreeM m a -> MaybeT m (Cofree (MaybeT m) a)

-- | Convert a <a>Cofree</a> <a>MaybeT</a> to a <a>FoldableFreeM</a>
fromCofreeMaybe :: Monad m => Cofree (MaybeT m) a -> FoldableFreeM m a

-- | Fold monadically into a <a>Cofree</a> <a>MaybeT</a>
cofreeMaybeT :: Monad m => FoldM m a (Maybe (Cofree (MaybeT m) a))

-- | Wrap a layer of monadic context into a <a>FoldableFreeM</a>
wrapFoldableFreeM :: Monad m => m (FoldableFreeM m a) -> FoldableFreeM m a

-- | Apply <a>wrapFoldableFreeM</a> and replace <a>Nothing</a> with
--   <a>empty</a>
wrapMaybeT :: Monad m => MaybeT m (FoldableFreeM m a) -> FoldableFreeM m a

-- | Unwrap a layer of monadic context from a <a>FoldableFreeM</a>
unwrapFoldableFreeM :: Monad m => FoldableFreeM m a -> m (FoldableFreeM m a)

-- | Uses <a>tabulateFoldM</a> and <a>indexFoldM</a>. See
--   <a>Distributive</a>.
distributeFoldM :: (Monad m, Distributive m, Functor f) => f (FoldM m a b) -> FoldM m a (f b)

-- | Index a <a>FoldM</a> using a <a>FoldableFreeM</a>. See
--   <tt>Representable</tt>.
indexFoldM :: Monad m => FoldM m a b -> FoldableFreeM m a -> m b

-- | Tabulate a <a>FoldM</a> by building up successive
--   <a>FoldableFreeM</a>s
tabulateFoldM :: Monad m => (FoldableFreeM m a -> m b) -> FoldM m a b

-- | Wrap a layer of the <a>Monad</a>ic context into a <a>FoldM</a>. See
--   <a>MonadFree</a>
wrapFoldM :: Monad m => m (FoldM m a b) -> FoldM m a b
instance (GHC.Base.Monad m, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Data.Foldable.Monadic.Free.FoldableFreeM m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Data.Foldable.Monadic.Free.FoldableFreeM m a)
instance (GHC.Base.Monad m, Data.Foldable.Foldable m) => Data.Foldable.Foldable (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance (GHC.Base.Monad m, Data.Traversable.Traversable m) => Data.Traversable.Traversable (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Data.Foldable.Monadic.FoldableM m (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance (Control.Comonad.Comonad m, GHC.Base.Monad m, (TypeError ...)) => Control.Comonad.Comonad (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Control.Monad.Free.Class.MonadFree m (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Control.Monad.Fix.MonadFix (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Control.Monad.Zip.MonadZip (Data.Foldable.Monadic.Free.FoldableFreeM m)
instance GHC.Base.Monad m => Control.Monad.Rep.RepresentableM m (Control.Foldl.FoldM m a)
instance Data.Functor.Classes.Eq1 m => Data.Functor.Classes.Eq1 (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Foldl.FoldM m a)
instance GHC.Base.Monad m => Control.Monad.Free.Class.MonadFree m (Control.Foldl.FoldM m a)


-- | This module provides a <a>FoldE</a> that returns a stream of outputs
module Control.Foldls.End

-- | A <a>FoldE</a> that returns a non-empty stream of outputs
newtype FoldsE a b
FoldsE :: FoldE a (FoldableFreeM (Either b) b) -> FoldsE a b
[runFoldsE] :: FoldsE a b -> FoldE a (FoldableFreeM (Either b) b)

-- | Right map over a <a>FoldsE</a>
rmapFoldsE :: (a -> b) -> (b -> a) -> FoldsE t a -> FoldsE t b

-- | Left map over a <a>FoldsE</a>
lmapFoldsE :: (a -> b) -> FoldsE b c -> FoldsE a c


-- | This module provides a <a>FoldM</a> that returns a monadic stream of
--   outputs
module Control.Foldls.Monadic

-- | A <a>FoldM</a> returning a <a>Monad</a>ic stream of outputs.
--   
--   <pre>
--   <a>FoldsM</a> m a b = <a>FoldM</a> m a (<a>RepM</a> (<a>FoldM</a> m b))
--   <a>FoldsM</a> m a b = <a>FoldM</a> m a (<a>FoldableFreeM</a> b)
--   
--   </pre>
newtype FoldsM m a b
FoldsM :: FoldM m a (FoldableFreeM m b) -> FoldsM m a b
[runFoldsM] :: FoldsM m a b -> FoldM m a (FoldableFreeM m b)

-- | Unwrap a layer of the <a>FoldsM</a>'s given <a>Monad</a>, e.g. to
--   catch an exception before continuing.
unwrapFoldsM :: Monad m => FoldsM m a b -> m (FoldsM m a b)

-- | <a>undefined</a>
readerToFoldsM :: Monad m => (forall x. FoldM (ReaderT x (FoldM m b)) a x) -> FoldsM m a b

-- | <a>undefined</a>
foldsMToReader :: Monad m => FoldsM m a b -> (forall x. FoldM (ReaderT x (FoldM m b)) a x)

-- | Simply <tt>(<a>return</a> :: b -&gt; <a>FoldableFreeM</a> m b)</tt>
--   the result of a <a>FoldM</a>
foldMToFoldsM :: Monad m => FoldM m a b -> FoldsM m a b
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Functor m => GHC.Generics.Generic1 (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Generics.Generic (Control.Foldls.Monadic.FoldsM m a b)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Data.Distributive.Monadic.DistributiveM (Data.Foldable.Monadic.Free.FoldableFreeM m) (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Control.Monad.Rep.RepresentableM (Data.Foldable.Monadic.Free.FoldableFreeM m) (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Control.Monad.Fix.MonadFix (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Control.Monad.Zip.MonadZip (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Data.Functor.Extend.Extend (Control.Foldls.Monadic.FoldsM m a)
instance (GHC.Base.Monad m, (TypeError ...)) => Control.Comonad.Comonad (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Control.Monad.Free.Class.MonadFree m (Control.Foldls.Monadic.FoldsM m a)
instance GHC.Base.Monad m => Data.Semigroupoid.Semigroupoid (Control.Foldls.Monadic.FoldsM m)
instance GHC.Base.Monad m => Control.Category.Category (Control.Foldls.Monadic.FoldsM m)


-- | This module provides an implementation of type-level natural numbers
--   and a <a>KnownN</a> that allows us to derive that <tt>c :: <a>N</a>
--   -&gt; Constraint</tt> holds for all <a>N</a> when we know that <tt>c
--   '<a>Z</a></tt> and <tt>forall (n :: <a>N</a>). c n =&gt; c ('<a>S</a>
--   n)</tt>.
--   
--   See <a>forallN</a> for more details.
module Data.N

-- | Type level natural numbers.
--   
--   Why not use <a>Nat</a> instead? I don't think <a>forallN</a> would be
--   possible.
data N
S :: N -> N
Z :: N

-- | The previous <a>N</a> or <a>Z</a> if <a>Z</a>

-- | Unpack a type-level <a>N</a> into either <a>Z</a> or <tt><a>S</a>
--   n</tt> for <tt>n ~ Pred n</tt>.
--   
--   This class alone is sufficient to implement many operations, since it
--   allows pattern matching on a type-level natural with resolution of the
--   type to its case when you match on the result.
class KnownN (n :: N)

-- | Unpack a type-level <a>N</a> into either an equivalence with <a>Z</a>
--   or one with <tt><a>S</a> (<a>Pred</a> n)</tt>. Performed recursively,
--   this allows one to unpack a type-level <a>N</a> completely.
unpackN :: KnownN n => proxy n -> Either (n :~:  'Z) (n :~:  'S (Pred n))

-- | Any time we can unpack a <a>N</a>, we can unpack its predecessor.
--   
--   (It's easy to see this from within the <a>KnownN</a> instances, the
--   implementations are just <a>Dict</a>.)
unpackPredN :: KnownN n => proxy n -> Dict (KnownN (Pred n))

-- | Using <a>forallN</a>, we can convert <a>KnownN</a> to any inductive
--   class constraint on <a>N</a>.
--   
--   Use like so:
--   
--   <pre>
--   class ToNatural (n :: <a>N</a>) where
--     toNatural_ :: proxy n -&gt; <tt>Natural</tt>
--   
--   instance ToNatural '<a>Z</a> where
--     toNatural_ _ = 0
--   
--   instance ToNatural n =&gt; ToNatural ('<a>S</a> n) where
--     toNatural_ proxyN = 1 + toNatural_ (<a>predProxy</a> proxyN)
--   
--   forallToNatural :: <a>KnownN</a> n =&gt; proxy n -&gt; <a>Dict</a> (ToNatural n)
--   forallToNatural _ = <a>forallN</a> <a>Dict</a> (<a>Sub</a> <a>Dict</a>)
--   
--   toNatural :: <a>KnownN</a> n =&gt; proxy n -&gt; <tt>Natural</tt>
--   toNatural proxyN = forallToNatural proxyN `<a>withDict</a>` toNatural_ proxyN
--   </pre>
--   
--   In other words, this converts <a>KnownN</a> to any class constraint
--   that's defined inductively over <a>N</a>.
--   
--   If you have trouble defining the final method since the <tt>(n ::
--   <a>N</a>)</tt> is only contained in the result, try this method:
--   
--   <pre>
--   naryFooProxy :: <a>KnownN</a> n =&gt; prxy n -&gt; a -&gt; f n a
--   naryFooProxy prxy x = forallFoo prxy `<a>withDict</a>` fooClass x
--   
--   naryFoo :: KnownN n =&gt; a -&gt; f n a
--   naryFoo = naryFooProxy <a>Proxy</a>
--   </pre>
forallN :: forall (c :: N -> Constraint) (n :: N) (proxy :: N -> *). KnownN n => Dict (c  'Z) -> (forall (n' :: N). c n' :- c ( 'S n')) -> proxy n -> Dict (c n)

-- | Conversion from <a>Nat</a> to <a>N</a>

-- | Convert a type-level <a>Nat</a> to a type-level <a>N</a>
toN :: proxy n -> Proxy (ToN n)

-- | Conversion from <a>N</a> to <a>Nat</a>

-- | Convert a type-level <a>N</a> to a type-level <a>Nat</a>
fromN :: proxy n -> Proxy (FromN n)

-- | The precessor of a type-level <a>N</a>
predProxy :: proxy ( 'S n) -> Proxy n

-- | The the successor of a type-level <a>N</a>
succProxy :: proxy n -> Proxy ( 'S n)

-- | <a>unpackPred</a> works for all <tt>n</tt>
unpackPred :: proxy n -> KnownN n :- KnownN (Pred n)

-- | <a>unpackSucc</a> works for all <tt>n</tt>
unpackSucc :: proxy n -> KnownN n :- KnownN ( 'S n)
instance GHC.Read.Read Data.N.N
instance GHC.Show.Show Data.N.N
instance GHC.Classes.Ord Data.N.N
instance GHC.Classes.Eq Data.N.N
instance Data.N.KnownN 'Data.N.Z
instance Data.N.KnownN n => Data.N.KnownN ('Data.N.S n)
instance GHC.Enum.Enum Data.N.N
instance GHC.Num.Num Data.N.N
instance GHC.Real.Real Data.N.N
instance GHC.Real.Integral Data.N.N


-- | This module defines n-ary functions and operations on them.
module Control.Nary

-- | N-ary functions
--   
--   <pre>
--   λ&gt; :t Ary0 ()
--   Ary0 () :: Ary 'Z a ()
--   
--   λ&gt; :t Ary $ x -&gt; Ary0 (succ x)
--   Ary $ x -&gt; Ary0 (succ x) :: Enum b =&gt; Ary ('S 'Z) b b
--   
--   λ&gt; :t Ary . (Ary .) $ x y -&gt; Ary0 [x, y]
--   Ary . (Ary .) $ x y -&gt; Ary0 [x, y] :: Ary ('S ('S 'Z)) b [b]
--   </pre>
data Ary (n :: N) (a :: *) (b :: *)
[Ary0] :: b -> Ary  'Z a b
[Ary] :: (a -> Ary n a b) -> Ary ( 'S n) a b

-- | Unwrap a single layer from a <a>Ary</a>
unwrapAry :: Ary ( 'S n) a b -> a -> Ary n a b

-- | Get the <tt>n</tt> (arity) from a <a>Ary</a>
arity :: Ary n a b -> Proxy n

-- | Conversions between representations of an n-ary function
class KnownN n => AryClass n where {
    type family NAry (n :: N) a b :: *;
}

-- | Convert a specific arity fuinction to a <a>Ary</a>
toAryClass :: AryClass n => NAry n a b -> Ary n a b

-- | Convert a <a>Ary</a> to a specific arity fuinction
fromAryClass :: AryClass n => Ary n a b -> NAry n a b

-- | All <a>KnownN</a>'s are <a>AryClass</a>
forallAryClass :: KnownN n => proxy n -> Dict (AryClass n)

-- | Convert an n-ary function to <a>Ary</a>:
--   
--   <pre>
--   toAry ()           :: Ary (ToN 0) Int () :: Ary 'Z Int ()
--   toAry (_ -&gt; ())   :: Ary (ToN 1) Int () :: Ary ('S 'Z) Int ()
--   toAry (_ _ -&gt; ()) :: Ary (ToN 2) Int () :: Ary ('S ('S 'Z)) Int ()
--   </pre>
toAry :: KnownN n => NAry n a b -> Ary n a b

-- | Helper to fix <tt>n</tt> in <a>toAry</a>
toAryProxy :: KnownN n => proxy n -> NAry n a b -> Ary n a b

-- | Convert <a>Ary</a> to an n-ary function
fromAry :: KnownN n => Ary n a b -> NAry n a b

-- | Conversions between n-ary functions and <a>Fold</a>s
class KnownN n => FoldAry n
naryFoldClass :: FoldAry n => Ary n a b -> Fold a (Maybe b)
naryFoldMClass :: (FoldAry n, Monad m) => Ary n a (m b) -> FoldM (MaybeT m) a b
naryFromFoldClass :: FoldAry n => Fold a b -> Ary n a b
naryFromFoldMClass :: (FoldAry n, Monad m) => FoldM m a b -> Ary n a (m b)

-- | All <a>KnownN</a>'s are <a>FoldAry</a>
forallFoldAry :: KnownN n => proxy n -> Dict (FoldAry n)

-- | Convert <a>Ary</a> to a <a>Fold</a>, returning <a>Nothing</a> if there
--   are fewer than <tt>n</tt> elements folded.
naryFold :: KnownN n => Ary n a b -> Fold a (Maybe b)

-- | Convert <a>Ary</a> to a <a>FoldM</a>, returning <a>empty</a> if there
--   are fewer than <tt>n</tt> elements folded.
naryFoldM :: KnownN n => Monad m => Ary n a (m b) -> FoldM (MaybeT m) a b

-- | Convert a <a>Fold</a> to an arbitrary-sized <a>Ary</a> function
naryFromFold :: KnownN n => Fold a b -> Ary n a b

-- | Helper to fix <tt>n</tt> in <a>naryFromFold</a>
naryFromFoldProxy :: KnownN n => prxy n -> Fold a b -> Ary n a b

-- | Convert a <a>FoldM</a> to an arbitrary-sized <a>Ary</a> function
naryFromFoldM :: (KnownN n, Monad m) => FoldM m a b -> Ary n a (m b)

-- | Helper to fix <tt>n</tt> in <a>naryFromFoldM</a>
naryFromFoldMProxy :: (KnownN n, Monad m) => proxy n -> FoldM m a b -> Ary n a (m b)

-- | All <a>KnownN</a>'s are <a>DistributiveAry</a>
forallDistributiveAry :: KnownN n => proxy n -> Dict (DistributiveAry n)

-- | Polymorphic definitions of <a>distribute</a> and <a>collect</a> over
--   <a>N</a> |
class KnownN n => DistributiveAry n

-- | <a>distribute</a> for a particular <a>N</a>
distributeAryClass :: (DistributiveAry n, Functor f) => f (Ary n a b) -> Ary n a (f b)

-- | <a>collect</a> for a particular <a>N</a>
collectAryClass :: (DistributiveAry n, Functor f) => (a -> Ary n b c) -> f a -> Ary n b (f c)

-- | Polymorphic definition of <a>pure</a> and <tt>(<a>&lt;*&gt;</a>)</tt>
--   over <a>N</a>
class KnownN n => ApplicativeAry n
pureAryClass :: ApplicativeAry n => b -> Ary n a b
apAryClass :: ApplicativeAry n => Ary n a (b -> c) -> Ary n a b -> Ary n a c

-- | <tt>pureAry</tt> with a <tt>proxy</tt> argument to determine the
--   result size.
pureAryProxy :: KnownN n => proxy n -> b -> Ary n a b

-- | Polymorphic definition of <tt>(<a>&gt;&gt;=</a>)</tt> over <a>N</a>
class KnownN n => BindAry n
bindAryClass :: BindAry n => Ary n a b -> (b -> Ary n a c) -> Ary n a c

-- | Polymorphic definition of <a>extract</a> and <a>duplicate</a> over
--   <a>N</a>
class KnownN n => ComonadAry n

-- | <a>extract</a> for a particular <a>N</a>
extractAryClass :: (ComonadAry n, Monoid a) => Ary n a b -> b

-- | <a>duplicate</a> for a particular <a>N</a>
duplicateAryClass :: (ComonadAry n, Monoid a) => Ary n a b -> Ary n a (Ary n a b)

-- | Shift an argument of an <a>Ary</a> function in a level
class KnownN n => ShiftAry n
shiftAryClass :: ShiftAry n => Ary ( 'S n) a (Ary m a b) -> Ary n a (Ary ( 'S m) a b)

-- | Shift an argument of an <a>Ary</a> function in one level
shiftAry :: KnownN n => Ary ( 'S n) a (Ary m a b) -> Ary n a (Ary ( 'S m) a b)

-- | Apply an <a>Ary</a> function to a value <tt>n</tt> times
replicateApply :: Ary n a b -> a -> b

-- | Apply an <a>Ary</a> function to a <a>Monad</a>ic value by repeating
--   its action.
replicateMApply :: Monad m => Ary n a b -> m a -> m b

-- | Join two, possibly different, proxies into a single <a>Proxy</a>
joinProxy :: forall (proxy :: kp -> *) (proxy' :: ka -> kp) (a :: ka). proxy (proxy' a) -> Proxy a

-- | <tt>(<a>&gt;&gt;=</a>)</tt> generalized to two (possibly different)
--   proxies
bindProxy :: forall (proxy :: * -> *) (proxy' :: k -> *) (a :: *) (b :: k). proxy a -> (a -> proxy' b) -> Proxy b

-- | Convert a function to a <a>Proxy</a> containing its result type
proxyResult :: (a -> b) -> Proxy b

-- | Arrows that behave like <a>Kleisli</a> arrows
class (Monad m, Arrow a) => ArrowM m a | a -> m
arrM :: ArrowM m a => (b -> m c) -> a b c
joinA :: ArrowM m a => a (m b) b
instance GHC.Base.Monad m => Control.Nary.ArrowM m (Control.Arrow.Kleisli m)
instance Control.Nary.ArrowM Data.Functor.Identity.Identity (->)
instance Control.Nary.ShiftAry 'Data.N.Z
instance Control.Nary.ShiftAry n => Control.Nary.ShiftAry ('Data.N.S n)
instance Control.Nary.ComonadAry 'Data.N.Z
instance (Data.N.KnownN n, Control.Nary.ComonadAry n) => Control.Nary.ComonadAry ('Data.N.S n)
instance (Data.N.KnownN n, GHC.Base.Monoid a) => Control.Comonad.Comonad (Control.Nary.Ary n a)
instance Data.N.KnownN n => GHC.Base.Monad (Control.Nary.Ary n a)
instance Control.Nary.BindAry 'Data.N.Z
instance Control.Nary.BindAry n => Control.Nary.BindAry ('Data.N.S n)
instance Data.N.KnownN n => GHC.Base.Applicative (Control.Nary.Ary n a)
instance Control.Nary.ApplicativeAry 'Data.N.Z
instance Control.Nary.ApplicativeAry n => Control.Nary.ApplicativeAry ('Data.N.S n)
instance Data.N.KnownN n => Data.Distributive.Distributive (Control.Nary.Ary n a)
instance Control.Nary.DistributiveAry 'Data.N.Z
instance Control.Nary.DistributiveAry n => Control.Nary.DistributiveAry ('Data.N.S n)
instance Control.Nary.FoldAry 'Data.N.Z
instance Control.Nary.FoldAry n => Control.Nary.FoldAry ('Data.N.S n)
instance Control.Nary.AryClass 'Data.N.Z
instance Control.Nary.AryClass n => Control.Nary.AryClass ('Data.N.S n)
instance (Data.N.KnownN n, GHC.Base.Semigroup b) => GHC.Base.Semigroup (Control.Nary.Ary n a b)
instance (Data.N.KnownN n, GHC.Base.Monoid b) => GHC.Base.Monoid (Control.Nary.Ary n a b)
instance Data.Profunctor.Unsafe.Profunctor (Control.Nary.Ary n)
instance Data.Profunctor.Strong.Strong (Control.Nary.Ary ('Data.N.S 'Data.N.Z))
instance Data.Profunctor.Choice.Choice (Control.Nary.Ary n)
instance GHC.Base.Functor (Control.Nary.Ary n a)


-- | This module provides two pseudo-polymorphic data-types:
--   <a>PseudoPoly</a> and <tt>(<a>:&gt;-</a>)</tt>
module Data.PseudoPoly

-- | A Pseudo-polymorphic data-type.
--   
--   If <tt><a>PseudoPoly</a> a b c</tt> is inhabited by some terminating
--   value, then the type <tt>b</tt> is the same as the type <tt>c</tt>.
--   
--   To use this equality in practice, pattern-match on the
--   <tt><a>PseudoPoly</a> a b c</tt> to get out the constructor; in the
--   body of the pattern-match, the compiler knows that <tt>b ~ c</tt>.
--   
--   Alternatively, you may use the <a>eqPseudoPoly</a> helper to extract
--   the prepositional equality: <tt>b <a>:~:</a> c</tt>.
--   
--   For example, here we can pattern match on <a>PseudoPoly</a> to recover
--   the fact that <tt>b ~ c</tt>:
--   
--   <pre>
--   foo :: (c -&gt; d) -&gt; <a>PseudoPoly</a> a b c -&gt; (b -&gt; d)
--   f (<a>PseudoPoly</a> _) -&gt; f
--   </pre>
--   
--   Why is this useful? Take for example <a>Foldable</a>, which requires a
--   polymorphic data type, but doesn't strictly have to. This allows us to
--   declare a <a>Foldable</a> instance for something like
--   <tt>ByteString</tt> like so:
--   
--   <pre>
--   import qualified Data.ByteString.Char8 as C8
--   
--   instance <a>Foldable</a> (<a>PseudoPoly</a> C8.ByteString Char) where
--     <a>foldr</a> f x (<a>PseudoPoly</a> xs) = C8.foldr f x xs
--   </pre>
--   
--   It looks like magic.
data PseudoPoly a b c
[PseudoPoly] :: a -> PseudoPoly a b b

-- | Extract the value from a <a>PseudoPoly</a>. Since we do not depend on
--   the GADT constraints, we can do so lazily.
fromPseudoPoly :: PseudoPoly a b c -> a

-- | Extract the equality proof from a <a>PseudoPoly1</a>.
eqPseudoPoly :: PseudoPoly a b c -> b :~: c

-- | Symmetry of equality
swapPseudoPoly :: PseudoPoly a b c -> PseudoPoly a c b

-- | Apply a prepositional type equality to a <a>PseudoPoly</a>
transPseudoPoly :: (c :~: d) -> PseudoPoly a b c -> PseudoPoly a b d

-- | Map over the value in a <a>PseudoPoly</a>
mapPseudoPoly :: (a -> b) -> PseudoPoly a c d -> PseudoPoly b c d

-- | <a>PseudoPoly</a> where the second argument is applied to the first
data (:>-) a b c
[PseudoPoly1] :: a b -> (a :>- b) b

-- | Extract the value from a <tt>(<a>:&gt;-</a>)</tt>. Since we do not
--   depend on the GADT constraints, we can do so lazily.
fromPseudoPoly1 :: (a :>- b) c -> a b

-- | Extract the equality proof from a <tt>(<a>:&gt;-</a>)</tt>.
eqPseudoPoly1 :: (a :>- b) c -> b :~: c

-- | Symmetry of equality
swapPseudoPoly1 :: (a :>- b) c -> (a :>- c) b

-- | Apply a prepositional type equality to a <tt>(<a>:&gt;-</a>)</tt>
transPseudoPoly1 :: (c :~: d) -> (a :>- b) c -> (a :>- b) d

-- | Map over the value in a <tt>(<a>:&gt;-</a>)</tt>
mapPseudoPoly1 :: (a c -> b c) -> (a :>- c) d -> (b :>- c) d
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.PseudoPoly.PseudoPoly a b c)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.PseudoPoly.PseudoPoly a b c)
instance GHC.Show.Show a => GHC.Show.Show (Data.PseudoPoly.PseudoPoly a b c)
instance GHC.Read.Read a => GHC.Read.Read (Data.PseudoPoly.PseudoPoly a b b)
instance GHC.Classes.Eq (a b) => GHC.Classes.Eq ((Data.PseudoPoly.:>-) a b c)
instance GHC.Classes.Ord (a b) => GHC.Classes.Ord ((Data.PseudoPoly.:>-) a b c)
instance GHC.Show.Show (a b) => GHC.Show.Show ((Data.PseudoPoly.:>-) a b c)
instance GHC.Read.Read (a b) => GHC.Read.Read ((Data.PseudoPoly.:>-) a b b)
instance (TypeError ...) => GHC.Base.Functor (a Data.PseudoPoly.:>- b)
instance Data.Foldable.Foldable t => Data.Foldable.Foldable (t Data.PseudoPoly.:>- a)
instance (TypeError ...) => GHC.Base.Functor (Data.PseudoPoly.PseudoPoly a b)
instance Data.Foldable.Foldable (Data.PseudoPoly.PseudoPoly [a] a)
