-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ListT done right
--   
--   A correct implementation of the list monad-transformer. Useful for
--   basic streaming.
@package list-t
@version 1.0.1

module ListT

-- | A proper implementation of the list monad-transformer. Useful for
--   streaming of monadic data structures.
--   
--   Since it has instances of <a>MonadPlus</a> and <a>Alternative</a>, you
--   can use general utilities packages like <a>"monadplus"</a> with it.
newtype ListT m a
ListT :: (m (Maybe (a, ListT m a))) -> ListT m a

-- | Execute in the inner monad, getting the head and the tail. Returns
--   nothing if it's empty.
uncons :: ListT m a -> m (Maybe (a, ListT m a))

-- | Execute, getting the head. Returns nothing if it's empty.
head :: Monad m => ListT m a -> m (Maybe a)

-- | Execute, getting the tail. Returns nothing if it's empty.
tail :: Monad m => ListT m a -> m (Maybe (ListT m a))

-- | Execute, checking whether it's empty.
null :: Monad m => ListT m a -> m Bool

-- | Execute, applying a left fold.
fold :: Monad m => (r -> a -> m r) -> r -> ListT m a -> m r

-- | A version of <a>fold</a>, which allows early termination.
foldMaybe :: Monad m => (r -> a -> m (Maybe r)) -> r -> ListT m a -> m r

-- | Execute, folding to a list.
toList :: Monad m => ListT m a -> m [a]

-- | Execute, folding to a list in the reverse order. Performs more
--   efficiently than <a>toList</a>.
toReverseList :: Monad m => ListT m a -> m [a]

-- | Execute, traversing the stream with a side effect in the inner monad.
traverse_ :: Monad m => (a -> m ()) -> ListT m a -> m ()

-- | Execute, consuming a list of the specified length and returning the
--   remainder stream.
splitAt :: Monad m => Int -> ListT m a -> m ([a], ListT m a)

-- | Prepend an element.
cons :: Monad m => a -> ListT m a -> ListT m a

-- | Construct from any foldable.
fromFoldable :: (Monad m, Foldable f) => f a -> ListT m a

-- | Construct from an MVar, interpreting the value of Nothing as the end.
fromMVar :: (MonadIO m) => MVar (Maybe a) -> ListT m a

-- | Construct by unfolding a pure data structure.
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> ListT m a

-- | Construct by unfolding a monadic data structure
--   
--   This is the most memory-efficient way to construct ListT where the
--   length depends on the inner monad.
unfoldM :: Monad m => (b -> m (Maybe (a, b))) -> b -> ListT m a

-- | Produce an infinite stream.
repeat :: Monad m => a -> ListT m a

-- | A transformation, which traverses the stream with an action in the
--   inner monad.
traverse :: Monad m => (a -> m b) -> ListT m a -> ListT m b

-- | A transformation, reproducing the behaviour of
--   <tt>Data.List.<a>take</a></tt>.
take :: Monad m => Int -> ListT m a -> ListT m a

-- | A transformation, reproducing the behaviour of
--   <tt>Data.List.<a>drop</a></tt>.
drop :: Monad m => Int -> ListT m a -> ListT m a

-- | A transformation, which slices a list into chunks of the specified
--   length.
slice :: Monad m => Int -> ListT m a -> ListT m [a]
instance GHC.Base.Monad m => GHC.Base.Semigroup (ListT.ListT m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (ListT.ListT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (ListT.ListT m)
instance (GHC.Base.Monad m, GHC.Base.Functor m) => GHC.Base.Applicative (ListT.ListT m)
instance (GHC.Base.Monad m, GHC.Base.Functor m) => GHC.Base.Alternative (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (ListT.ListT m)
instance Control.Monad.Trans.Class.MonadTrans ListT.ListT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (ListT.ListT m)
instance Control.Monad.Morph.MFunctor ListT.ListT
instance Control.Monad.Morph.MMonad ListT.ListT
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (ListT.ListT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (ListT.ListT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (ListT.ListT m)
